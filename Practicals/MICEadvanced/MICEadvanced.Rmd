---
title: "Multiple Imputation in complex settings"
output: 
#   html_document:
#     code_folding: hide
#     df_print: paged
#     toc: true
#     toc_float:
#       collapsed: false
#     number_sections: false
#     theme: spacelab
#     highlight: tango
#     pandoc_args: [
#       "--output=Practical_MICE.html"
#     ]
#     css: mycss.css
# editor_options:
#   chunk_output_type: inline
  learnr::tutorial:
    progressive: true
    allow_skip: true
    toc_depth: 3
runtime: shiny_prerendered
---

```{r, include = F}
if (names(rmarkdown::metadata$output) == "learnr::tutorial") {
  library(learnr)
  learnr::initialize_tutorial()
  static <- FALSE
}

if (names(rmarkdown::metadata$output) == "html_document") {
  knitr::opts_hooks$set(eval = function(opt) {
    if (any(opt$exercise, opt$eval == FALSE))
      opt$eval <- opt$include <- FALSE
    
    opt
  })
  
  static <- TRUE
}
```

```{r packages, include = FALSE}
library(JointAI)
library(jomo)
library(lme4)
library(mice)
library(nlme)
library(smcfcs)
library(survival)

library(magrittr)
library(knitr)
library(kableExtra)
```

```{r data, include = FALSE, context = "data"}

# NHANES data
load("www/NHANES.RData")
NHANES <- subset(NHANES, select = c("weight", "gender", "bili", "age", "chol",
                                    "HDL", "educ", "DBP", "height"),
                 subset = !is.na(weight) & !is.na(educ))

set.seed(2018)
sub <- sample(nrow(NHANES), 750, 
              prob = c(4/5, 1/5)[as.numeric(complete.cases(NHANES)) + 1])
NHANES <- NHANES[sub, ]


# pbcdata
pbcdat <- subset(pbc, 
                 select = c("time", "status", "platelet", "age",
                            "sex", "chol", "stage"))
pbcdat$status <- factor(pbcdat$status,
                        levels = 0:2,
                        labels = c("censored", "transplant", "dead"))
pbcdat$stage <- factor(pbcdat$stage, ordered = TRUE)

pbcdat$time <- as.numeric(pbcdat$time)
pbcdat$platelet <- as.numeric(pbcdat$platelet)
pbcdat$chol <- as.numeric(pbcdat$chol)

```

```{r savemodels interact, echo = FALSE, eval = FALSE}
set.seed(2018)
t0 <- Sys.time()
JointAIint <- lm_imp(weight ~ gender + bili + age * (chol + HDL) + height,
           data = NHANES, n.iter = 500, inits = NULL,
           auxvars = c("DBP", "educ"))
t1 <- Sys.time()

traceplot(JointAIint)

pred <- matrix(nrow = ncol(NHANES), ncol = ncol(NHANES), data = 1,
               dimnames = list(names(NHANES), names(NHANES)))
diag(pred) <- 0

set.seed(2018)
smcint <- smcfcs(NHANES,
                 smtype = "lm",
                 smformula = "weight ~ gender + bili + age * (chol + HDL) + height",
                 method = c(weight = "", gender = "", bili = "norm", age = "",
                            chol = "norm", HDL = "norm", educ = "", DBP = 'norm',
                            height = 'norm'), 
                 predictorMatrix = pred, rjlimit = 3000,
                 numit = 20)

par(mfrow = c(3, 4), mar = c(3.5, 3.5, 1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(smcint$smCoefIter)[2]) {
  matplot(t(smcint$smCoefIter[, i, ]), type = 'l', ylab = "coefficient", 
          xlab = "iteration")
}


set.seed(2018)
jomoint <- jomo.lm(weight ~ gender + bili + age * (chol + HDL) + height,
                   data = NHANES, nburn = 1000, 
                    nbetween = 200, nimp = 5, output = 0)
t0 <- Sys.time()
jomointMCMC <- jomo.lm.MCMCchain(weight ~ gender + bili + age * (chol + HDL) + height,
                    data = NHANES, nburn = 1000, output = 0)
t1 <- Sys.time()

par(mfrow = c(3,4), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomointMCMC$collectbeta)[2]) {
  plot(jomointMCMC$collectbeta[1, i, ], type = 'l')
}

par(mfrow = c(3,3), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomointMCMC$collectbetaY)[2]) {
  plot(jomointMCMC$collectbetaY[1, i, ], type = 'l')
}


par(mfrow = c(6, 6), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomointMCMC$collectomega)[2]) {
  for (j in 1:i) {
    plot(jomointMCMC$collectomega[i, j , ], type = 'l')
  }
}


save(JointAIint, smcint, jomoint, jomointMCMC, 
     file = "Practicals/MICEadvanced/www/intimps.RData")
```

```{r savemodels surv, echo = FALSE, eval = FALSE}
pbcdat$event <- pbcdat$status == 'dead'


set.seed(2018)
jomosurvMCMC <- jomo.coxph.MCMCchain(formula = Surv(time, event) ~ platelet + 
                                       age + sex + chol + stage,
                                     data = pbcdat, nburn = 2000)


par(mfrow = c(3,3), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomosurvMCMC$collectbeta)[2]) {
  plot(jomosurvMCMC$collectbeta[1, i, ], type = 'l')
}

par(mfrow = c(2,4), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomosurvMCMC$collectbetaY)[2]) {
  plot(jomosurvMCMC$collectbetaY[1, i, ], type = 'l')
}


par(mfrow = c(6, 8), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomosurvMCMC$collectomega)[2]) {
  for (j in 1:i) {
    plot(jomosurvMCMC$collectomega[i, j , ], type = 'l')
  }
}

matplot(t(jomosurvMCMC$collectbeta[1, , ]), type = 'l')

set.seed(2018)
jomosurv <- jomo.coxph(formula = Surv(time = time, event) ~ platelet + 
                         age + sex + chol + stage,
                       data = pbcdat, nburn = 2000,
                       nbetween = 500, nimp = 5)




pbcdat$event <- pbcdat$status == 'dead'

set.seed(2018)
smcsurv <- smcfcs(originaldata = pbcdat,
                  smtype = "coxph", 
                  smformula = "Surv(time = time, event) ~ platelet + 
                               age + sex + chol + stage",
                  method = c(time = "", status = "", 
                             platelet = "norm", age = "", sex = "", 
                             chol = "norm", stage = "podds", event = ""),
                  numit = 20, rjlimit = 1500)


par(mfrow = c(2, 4), mar = c(3.5, 3.5, 1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(smcsurv$smCoefIter)[2]) {
  matplot(t(smcsurv$smCoefIter[, i, ]), type = 'l', ylab = "coefficient", 
          xlab = "iteration")
}

save(jomosurvMCMC, jomosurv, smcsurv, file = "Practicals/MICEadvanced/www/survimps.RData")
```


```{r loadmodels, echo = FALSE, context = "data"}
load("www/survimps.RData")
load("www/intimps.RData")
```

## Non-linear functional forms
### Data & Model of interest
To practice imputation when non-linear functional forms or interaction terms
are involved, we use a subset of the **NHANES** data.

The variables in this subset have the following distribution:
```{r distrNHANES, echo = FALSE, fig.width = 9, fig.height = 6}
nc <- 4
nr <- 3

par(mfrow = c(nr, nc), mgp = c(2, 0.6, 0), mar = c(2, 3, 3, 0.5))

for (i in 1:ncol(NHANES)) {
  if (is.numeric(NHANES[, i])) {
    hist(NHANES[, i], nclass = 50, xlab = "",
         main = paste0(names(NHANES[i]), " (",
                       round(mean(is.na(NHANES[, i])) * 100, 2), "% NA)")
    )
  } else {
    cattab <- table(NHANES[, i], exclude = NULL)
    names(cattab)[is.na(names(cattab))] <- "NA"
    barplot(cattab, ylab = "Frequency",
            main = paste0(names(NHANES[i]), " (",
                          round(mean(is.na(NHANES[, i])) * 100, 2), "% NA)"))
  }
}
```


The **missing data pattern** is

```{r NHANESmdpat, echo = FALSE}
par(mar = c(4, 1, 1, 3), mgp = c(2, 0.6, 0))
md_pattern(NHANES, yaxis_pars = list(yaxt = 'n'), printN = FALSE)
```


We are interested to fit the following **linear regression model for
weight**. We expect that the effects of cholesterol and HDL
may differ with age, and, hence, include **interaction terms**
between `age` and `chol` and `HDL`, respectively.

```{r NHANESmodel, eval = FALSE}
mod <- lm(weight ~ weight ~ gender + bili + age * (chol + HDL) + height)
```

Additionally, we want to include `educ` and `DBP` as auxiliary variables.


### JointAI
The package **JointAI** performs analysis and imputation jointly.
There are three main functions, `lm_imp()`, `glm_imp()` and `lme_imp()` that
perform linear regression, generalized linear regression and linear mixed
model regression. The specification of these functions is very similar to the use
of their complete
data versions `lm()`, `glm()` and `lme` (from the **nlme** package).

Check the [help file](https://www.rdocumentation.org/packages/JointAI/versions/0.1.0/topics/model_imp)
for `lm_imp()` to find out which arguments you need to specify to fit the 
linear regression model for `weight`.

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

`lm_imp()`, `glm_imp()` and `lme_imp()` have many arguments, but not all of 
them are relevant for this practical. The most important arguments are:
```{r JointAIargs, echo = FALSE}
JointAIargs <- rbind(
  c("`formula`", "model formula"),
  c("`data`", "original, incomplete dataset"),
  c("`family`", "for glm's: the distribution family of the outcome"),
  c("`n.chains`", "number of MCMC chains"),
  c("`n.adapt`", "number of iterations used in the adaptive phase (details see below)"),
  c("`n.iter`", "number of iterations per MCMC chain in the sampling phase"),
  c("`auxvars`", paste0("vector of names of variables that are not part of the analysis",
                        " model but should be used to predict missing values (optional)")),
  c("`refcats`", "allows to specify which category of categorical variables is used as reference (optional)")
) %>% as.data.frame

names(JointAIargs) <- c("", "")

JointAIargs %>% kable(format = 'html') %>%
  kable_styling()

```


<b>Additional details:</b>
<br>
Contrary to MICE, the `n.chains` different MCMC chains are not used to create
multiple imputed datasets.
Multiple chains are necessary to evaluate if the model has converged.
For the final result the chains are combined.

Depending on the type of variable, different types of samplers (within the
Gibbs sampling) are used. JAGS (which is called from within `lm_imp()`)
needs an adaptive phase to find a suitable sampler for each of the parameters. 
Often `n.adapt = 100` iterations (the default value) are sufficient for the 
adaption phase.
These iterations are not included in the final result.

The number of iterations `n.iter` that is required depends on the specific
data and how complex the model is, hence, no default value is given.

Columns of the dataset that are not used in the model formula, and are not specified
as auxiliary variables are ignored. In the current version of **JointAI**,
passive imputation (calculating variables based on other variables) is not yet
available.


```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

Analyze (and impute) the data using `lm_imp()` and the linear regression model
specified above.

* Start with a small number of iterations, say `n.iter = 100`, to get an idea 
  about the computational time.
* Check convergence of the MCMC chains using `traceplot()`.
* Increase `n.iter` if necessary.


`traceplot()` shows by default the MCMC chains of the main model parameters.
This is different to the traceplots we have seen when using `mice()`, but the
principle of convergence is the same.


The result of the model can be displayed with the function `summary()`. 
To exclude parts of the MCMC chains from the result (if the ) part of the MCMC chains after
convergence was achieved, the argument `start` can be used to
specify the first iteration to be used. See an example in the
[help page](https://www.rdocumentation.org/packages/JointAI/versions/0.1.0/topics/summary.JointAI)
of the `summary()` for `JointAI` objects.

<div style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
Note: Due to a bug in the current version of **JointAI** you need to specify
`inits = NULL`. This bug will be resolved in the next version of the package.
</div>

```{r fitJointAIint, exercise = TRUE, timelimit.exercise = 200, fig.width = 9, fig.height = 4.5}
library(JointAI)
JointAIint <- ...


```

```{r fitJointAIint-hint-1}
# You need to specify the 
# * model formula
# * the dataset
# * auxiliary variables
# * the number of iterations for the sample
# * set inits = NULL
```

```{r, fitJointAIint-solution}
library(JointAI)
JointAIint <- lm_imp(weight ~ gender + bili + age * (chol + HDL) + height,
                  data = NHANES,
                  auxvars = c("educ", "DBP"),
                  n.iter = 500, inits = NULL)

traceplot(JointAIint)

summary(JointAIint, start = 200)
```



### smcfcs
The package **smcfcs** performs imputation using
"substantive model compatible fully conditional specification".

The main function is called `smcfcs()` and its use is similar to the use
of `mice()`. Check the [help file](https://www.rdocumentation.org/packages/smcfcs/versions/1.3.0/topics/smcfcs)
to find out the details of this function.

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```


<div id = "smcdetails">`smcfcs()` takes the following arguments as input:</div>
```{r smcargs, echo = FALSE}
smctab <- rbind(
  c("`originaldata`", "original, incomplete data frame"),
  c("`smtype`", paste0("type of substantive (analysis) model: `lm`, `logistic`, ",
                       "`poisson`, `coxph` or `compet`")),
  c("`smformula`", "formula of analysis model"),
  c("`method`", paste0("vector of imputation methods for each variable: ",
                       "`norm` (lin. regression), `logreg` (logistic regression), ",
                       "`poisson` (Poisson regression),",
                       "`podds` (prop. odds regression for ordered factors,",
                       "`mlogit` (multinomial logistic regression for unordered factors) ",
                       "`''` if variable is complete, or a custom expression ",
                       "to impute passively imputed variables, e.g. `'x^2'` or `x1*x2`")),
  c("`predictorMatrix`", paste0("predictor matrix to define which variables ",
                                "are used as predictors in which imputation ",
                                "model (optional). **The outcome must not be included**")),
  c("`m`", "number of imputed datasets (default is 5)"),
  c("`numit`", "number of iterations before obtaining imputed dataset"),
  c("`rjlimit`", "maximum number of attempts in the rejection sampling (MCMC)"),
  c("`noisy`", "if `TRUE`: output is printed, if `FALSE`: less output is printed")
) %>% as.data.frame

names(smctab) <- c("", "")

smctab %>% kable(format = 'html') %>%
  kable_styling()
```

<b>Additional details:</b>
<br>

The vector of imputation methods needs to be specified in the order of
the columns in the dataset and contain an entry for each column, even that 
column is not used in the imputation model.
Depending on whether additional columns of the data should be used as auxiliary
variables in the imputation, the `predictorMatrix` needs to be adjusted (0 if
the column should not be used, 1 if it should be used).

In `smcfcs()` the outcome of the analysis model is implicitely included in the
imputation model, similarily to how it is included in **JointAI**. Therefore,
the outcome does not need to be explicitely specified as predictor variable
for the imputation models in the `predictorMatrix`.

**smcfcs** uses *rejection sampling*. Rejection sampling is a method to create
a random sample from a complex distribution (from which we can not sample directly)
by drawing from a simpler proposal distribution and rejecting draws that are unlikely
under the complex target distribution.
The argument `rjlimit` specifies how many attepts are made to draw a value from
the proposal that is not rejected.


For logistic regression, `smcfcs` requires the outcome to be coded as numeric
(with values 0 and 1).

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

Impute the NHANES data with `smcfcs()` and take the following into account
that `DBP` and `educ` should be used as auxiliary variables.<br>
=> you need to specify the `predictorMatrix` to specify this

```{r runsmcint, exercise = TRUE, timelimit.exercise = 200}
# create the predictor Matrix
...

# run the imputation
smcint <- ...
```


```{r runsmcint-hint-1}
# To create the predictor matrix:
pred <- matrix(nrow = ncol(NHANES), ncol = ncol(NHANES), data = 1,
               dimnames = list(names(NHANES), names(NHANES)))
# exclude variables from their own imputation model
diag(pred) <- 0
```


```{r runsmcint-hint-2}
# In smcfcs() you need to specify 
# * the data
# * the model type
# * the model formula
# * the vector of imputation methods
# * the predictor matrix
# * possibly the number of iterations
```


```{r runsmcint-solution}
pred <- matrix(nrow = ncol(NHANES), ncol = ncol(NHANES), data = 1,
               dimnames = list(names(NHANES), names(NHANES)))
diag(pred) <- 0


smcint <- smcfcs(NHANES,
                 smtype = "lm",
                 smformula = "weight ~ gender + bili + age * (chol + HDL) + height",
                 method = c(weight = "", gender = "", bili = "norm", age = "",
                            chol = "norm", HDL = "norm", educ = "", DBP = 'norm',
                            height = 'norm'), 
                 predictorMatrix = pred, numit = 20)
```



Find out the `class` of the object returned by `smcfcs()` and its elements.
The section **Value** in the [help page](https://www.rdocumentation.org/packages/smcfcs/versions/1.3.0/topics/smcfcs)
can help with this.
Then plot the chains of the estimated model parameters to evaluate if the
algorithm has converged.
```{r conv_smcint, exercise = TRUE, fig.width = 9, fig.height = 6}

```


```{r conv_smcint-hint-1}
# The estimates of the model parameters from each iteration are returned
# in the list element "smCoefIter".
```


```{r conv_smcint-solution, fig.width = 9, fig.height = 6}
# class of the returned object
class(smcint)
# names of its components
names(smcint)

# investigate the first component
class(smcint$impDatasets)
length(smcint$impDatasets)
class(smcint$impDatasets[[1]])
dim(smcint$impDatasets[[1]])

# investigate the second component
class(smcint$smCoefIter)
dim(smcint$smCoefIter)


# plot the chains of estimated coefficients
par(mfrow = c(3, 3), mar = c(3.5, 3.5, 1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(smcint$smCoefIter)[2]) {
  matplot(t(smcint$smCoefIter[, i, ]), type = 'l', ylab = "coefficient", 
          xlab = "iteration")
}
```


```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```


The imputed datasets are returned as a `list`, where each element of the `list`
is one imputed dataset.

To get from a `list` of datasets to pooled results there are several options, as
displayed in the following flow chart:

<img src="www/Flowdiagram.svg" style="width:100%">

To use `datalist2mids()` from the package **miceadds**, ordered factors need to be converted to
unordered factors. To use `as.mids()` we would have to turn the list into
a long format dataset (where the original data and all imputed datasets are
stacked on top of each other) and add
a column that identifies the imputation numer and one that identifies subjects.

Instead do the following:

1. convert `smcint` to an `imputationList` object
2. fit the models on this `imputationList` object
3. use `MIcombine()` to obtain an `MIresult` object
4. use `as.mira()` to convert the `list` of models from 2. to a `mira` object
5. use `pool()` on the `mira` object
6. compare the `summary()` of the `mira` object and the `summary()` of the `MIresult` object


```{r pool_smcint, exercise = TRUE}

```



```{r pool_smcint-hint-1}
# 1. convert to imputationList
library(mitools)
smcint_impList <- imputationList(smcint$impDatasets)
```

```{r pool_smcint-hint-2}
# 1. convert to imputationList
library(mitools)
smcint_impList <- imputationList(smcint$impDatasets)

# 2. fit the models
intmod_mitools <- with(smcint_impList, 
                       lm(weight ~ gender + bili + age * (chol + HDL) + height))
```

```{r pool_smcint-hint-3}
# 1. convert to imputationList
library(mitools)
smcint_impList <- imputationList(smcint$impDatasets)

# 2. fit the models
intmod_mitools <- with(smcint_impList, 
                       lm(weight ~ gender + bili + age * (chol + HDL) + height))

# 3. Pool the results
smcintpool_mitools <- MIcombine(intmod_mitools)


```


```{r pool_smcint-hint-4}
# 1. convert to imputationList
library(mitools)
smcint_impList <- imputationList(smcint$impDatasets)

# 2. fit the models
intmod_mitools <- with(smcint_impList, 
                       lm(weight ~ gender + bili + age * (chol + HDL) + height))

# 3. Pool the results
smcintpool_mitools <- MIcombine(intmod_mitools)

# 4. create a mira object
smcint_mira <- as.mira(intmod_mitools)
```

```{r pool_smcint-hint-5}
# 1. convert to imputationList
library(mitools)
smcint_impList <- imputationList(smcint$impDatasets)

# 2. fit the models
intmod_mitools <- with(smcint_impList, 
                       lm(weight ~ gender + bili + age * (chol + HDL) + height))

# 3. Pool the results
smcintpool_mitools <- MIcombine(intmod_mitools)

# 4. create a mira object
smcint_mira <- as.mira(intmod_mitools)


# 5. pool the mira object
smcintpool_mice <- pool(smcint_mira)
```

```{r pool_smcint-solution}
# 1. convert to imputationList
library(mitools)
smcint_impList <- imputationList(smcint$impDatasets)

# 2. fit the models
intmod_mitools <- with(smcint_impList, 
                       lm(weight ~ gender + bili + age * (chol + HDL) + height))

# 3. Pool the results
smcintpool_mitools <- MIcombine(intmod_mitools)

# 4. create a mira object
smcint_mira <- as.mira(intmod_mitools)


# 5. pool the mira object
smcintpool_mice <- pool(smcint_mira)

# 6. compare the results
summary(smcintpool_mitools)
summary(smcintpool_mice)
```



### jomo

In this part of the practical we will use **jomo** to impute the NHANES data 
with the joint model approach to multiple imputation. 

For our linear regression of `weight`, this can be  done using the function `jomo.lm()`.
Check the [help page](https://www.rdocumentation.org/packages/jomo/versions/2.6-1/topics/jomo.lm)
to find out which arguments need to be specified in `jomo.lm()`.

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```


The main arguments of `jomo.lm()` are:
```{r jomoargs, echo = FALSE}
jomoargs <- rbind(
  c("`formula`", "model formula"),
  c("`data`", "the original, incomplete data set"),
  c("`nburn`", "number of burnin iterations"),
  c("`nbetween`" , "Number of iterations between imputations"),
  c("`nimp`", "number of imputations (default is 5)"),
  c("`output`", "if 1: output at end of imputation, if $\neq1$: no output shown"),
  c("`out.iter`", "prints output info each `out.iter` iterations")
) %>% as.data.frame

names(jomoargs) <- c("", "")

jomoargs %>% kable(format = 'html') %>%
  kable_styling()
```

<b>Additional details:</b>
<br>

**jomo** only produces a single chain of MCMC samples. The first `nburn` iterations
are discarded as burnin. The next iteration forms the first imputed dataset.
The MCMC chain is then continued and after `nbetween` additional iterations 
the next imputed dataset is created. This step is repeated until `nimp` sets 
of imputed values are obtained.

Convergence of the MCMC sampler can not be checked on the same 
object that was used to create the imputed values. Instead, a separate function
has to be used: `jomo.lm.MCMCchain()`. It takes the same arguments as 
`jomo.lm()`, except for `nbetween` and `nimp`, and records all burnin iterations,
but does not create multiple imputed datasets.

**jomo** will use all columns that are in the dataset but not used in the
model formula as auxiliary variables. As in **JointAI**, specification of
passive imputation is currently not available.

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

Run `jomo.lm.MCMCchain()` for our linear regression of `weight` and 
investigate the resulting object.

```{r runjomointMCMC, exercise = TRUE, fig.width = 9, fig.height = 6, timelimit.exercise = 500}

```

```{r runjomointMCMC-hint-1}
# you need to specify
# * the model formula
# * the dataset
# * the distribution family of the outcome
# * the number of burnin iterations
```

```{r runjomointMCMC-hint-2}
jomointMCMC <- jomo.lm.MCMCchain(weight ~ gender + bili + age * (chol + HDL) + height,
                    data = NHANES, output = 0)

class(jomointMCMC)
names(jomointMCMC)
lapply(jomointMCMC, class)

```


```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```


`jomoint` is a `list` with six elements:

* `finimp` is the imputed dataset that was generated at the end of the burnin periode
* `finimp.latnorm` contains a `matrix` corresponding estimates of the latent normal
  distributions
* `collectbetaY` and `collectvarY` contain the MCMC samples throughout the 
  burin period for the coefficients of the analysis model and residual variation
* `collectbeta` and `collectomega` contain the MCMC samples throughout the 
  burnin periode for the mean and variance-covariance matrix of the multivariate normal distribution.


Make plots to evaluate convergence.
```{r jomointconv, exercise = TRUE, fig.widht = 9, fig.height = 9}

```


```{r jomointconv-solution, fig.width = 9, fig.height = 9}
par(mfrow = c(3,4), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomointMCMC$collectbeta)[2]) {
  plot(jomointMCMC$collectbeta[1, i, ], type = 'l')
}

plot(jomointMCMC$collectvarY, type = 'l')

par(mfrow = c(3,3), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomointMCMC$collectbetaY)[2]) {
  plot(jomointMCMC$collectbetaY[1, i, ], type = 'l')
}

windows()
par(mfrow = c(11, 11), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomointMCMC$collectomega)[2]) {
  for (j in 1:i) {
    plot(jomointMCMC$collectomega[i, j , ], type = 'l')
  }
}

```

When you are satisfied with the convergence, run the imputation with the 
number of burnin iterations that you found to be sufficient and explore the 
resulting object.

```{r runjomoint, exercise = TRUE}

```

```{r runjomoint-solution}
jomoint <- jomo.lm(weight ~ gender + bili + age * (chol + HDL) + height,
                    nburn = 1000, nbetween = 200, nimp = 5)

class(jomoint)
dim(jomoint)
summary(jomoint)
```


`jomo.lm()`  returns a `data.frame` in long format, including the original data.
**jomo** has added a column `id`  to identify subjects and a column `Imputation` 
that identifies the imputation number.

With this information and the flowchart from above, fit the linear regression
model for `weight` on the imputed data and pool the results.

```{r jomoint-pool, exercise = TRUE}

```

```{r jomoint-pool-solution}
jomoint_mids <- as.mids(jomoint, 
                        .imp = which(names(jomoint) == "Imputation"),
                        .id = which(names(jomoint) == "id")
)

jomoint_mira <- with(jomoint_mids,
                     lm(weight ~ gender + bili + age * (chol + HDL) + height))

summary(pool(jomoint_mira))
```

```{r resint-setup, echo = FALSE}
library(mitools)
smcint_impList <- imputationList(smcint$impDatasets)
intmod_mitools <- with(smcint_impList, 
                       lm(weight ~ gender + bili + age * (chol + HDL) + height))
smcint_mira <- as.mira(intmod_mitools)
smcintpool_mice <- pool(smcint_mira)



jomoint_mids <- as.mids(jomoint, 
                        .imp = which(names(jomoint) == "Imputation"),
                        .id = which(names(jomoint) == "id")
)

jomoint_mira <- with(jomoint_mids,
                     lm(weight ~ gender + bili + age * (chol + HDL) + height))
```


```{r resint, fig.width = 9, fig.height = 7, exercise = TRUE}
ccint <- with(NHANES, lm(weight ~ gender + bili + age * (chol + HDL) + height))

resint <- list(cc = cbind(ccint$coef, confint(ccint)),
               jomo = summary(pool(jomoint_mira))[, c("est", "lo 95", "hi 95")],
               smcfcs = summary(smcintpool_mice)[, c("est", "lo 95", "hi 95")],
               JointAI = summary(JointAIint)$stat[, c(1,3,4)])

resint <- lapply(1:length(resint), function(i) {
  x <- as.data.frame(resint[[i]])
  names(x) <- c("est", "lo", "hi")
  x$method <- names(resint)[i]
  x$name <- rownames(x)
  x$name <- gsub("gender2", "genderfemale", x$name)
  x
})

plotint <- as.data.frame(do.call(rbind, resint))

library(ggplot2)
ggplot(plotint, aes(x = method, y = est)) +
  geom_point() +
  geom_errorbar(aes(min = lo, max = hi)) +
  facet_wrap("name", scales = "free")
 
```

## Longitudinal data
### Data & Model of interest
### JointAI
### jomo


## Survival data
### Data & Model of interest
In this part of the practical, we will work with a subset of the **pbc** dataset,
which was obtained from  a trial on primary biliary cirrhosis (PBC) of the liver.

The variables contained in `pbcdat` are:
```{r, echo = FALSE}
pbctab <- rbind(
  c("time", "number of days between inclusion and death, transplantion, or 
    end of follow-up"),
  c("status", "status at `time` (censored, transplant, dead)"),
  c("age", "patient's  age at intake"),
  c("sex", "patient's sex"),
  c("platelet", "platelet count"),
  c("chol", "serum cholesterol"),
  c("stage", "histologic stage of disease")
) %>% as.data.frame

names(pbctab) <- c("", "")

pbctab %>% kable(format = 'html') %>%
  kable_styling()
```


The variables in `pbcdat` dataset have the following distributions:
```{r, echo = FALSE, fig.width = 9, fig.height = 4.5}
nc <- 4
nr <- 2

par(mfrow = c(nr, nc), mgp = c(2, 0.6, 0), mar = c(2, 3, 3, 0.5))

for (i in 1:ncol(pbcdat)) {
  if (is.numeric(pbcdat[, i])) {
    hist(pbcdat[, i], nclass = 50, xlab = "",
         main = paste0(names(pbcdat[i]), " (",
                       round(mean(is.na(pbcdat[, i])) * 100, 2), "% NA)")
    )
  } else {
    cattab <- table(pbcdat[, i], exclude = NULL)
    names(cattab)[is.na(names(cattab))] <- "NA"
    barplot(cattab, ylab = "Frequency",
            main = paste0(names(pbcdat[i]), " (",
                          round(mean(is.na(pbcdat[, i])) * 100, 2), "% NA)"))
  }
}
```

The missing data pattern is

```{r, echo = FALSE}
par(mar = c(4, 1, 1, 3), mgp = c(2, 0.6, 0))
md_pattern(pbcdat, yaxis_pars = list(yaxt = 'n'))
```



We are interested to determine predictor variables for patient survival, using
the following Cox proportional hazards model:
```{r, eval = FALSE}
coxph(Surv(time, status == 'dead') ~ platelet + age + sex + chol + stage)
```


### Imputation with **smcfcs**
First, we impute the data using the R package **smcfcs**. 

If you are uncertain which parameters need to be specified, check the
[help page](https://www.rdocumentation.org/packages/smcfcs/versions/1.3.0/topics/smcfcs)
for the function `smcfcs()` or go back to the first part of this practical
where some of the details about the specification were described.


Impute the pbc data with `smcfcs()` and the model formula specified above
and confirm that the algorithm has converged. If `smcfcs()` does have probems
with the event specification used above (`status == 'dead'`) you need to 
create a new variable instead.
```{r smcimp, exercise = TRUE, exercise.timelimit = 100, fig.width = 9, fig.height = 4.5}
smcsurv <- ...
```

```{r smcimp-hint-1}
# To create the event variable:
pbcdat$event <- as.numeric(pbcdat$status == 'dead')
```

```{r smcimp-hint-2}
# To create the event variable:
pbcdat$event <- as.numeric(pbcdat$status == 'dead')

# specify imputation method (in order of variables in dataset)
meth_smcsurv <- c(time = "", status = "", platelet = "norm",
                  age = "", sex = "", chol = "norm", stage = "podds",
                  event = "")
```

```{r smcimp-hint-3}
# To create the event variable:
pbcdat$event <- as.numeric(pbcdat$status == 'dead')

# specify imputation method (in order of variables in dataset)
meth_smcsurv <- c(time = "", status = "", platelet = "norm",
                  age = "", sex = "", chol = "norm", stage = "podds",
                  event = "")

# impute the data
smcsurv <- smcfcs(originaldata = pbcdat,
                  smtype = "coxph", 
                  smformula = "Surv(time = time, event) ~ platelet + 
                               age + sex + chol + stage",
                  method = meth_smcsurv, numit = 20)


# plots to check convergence
par(mfrow = c(2, 4), mar = c(3.5, 3.5, 1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(smcsurv$smCoefIter)[2]) {
  matplot(t(smcsurv$smCoefIter[, i, ]), type = 'l', ylab = "coefficient", 
          xlab = "iteration")
}

```


```{r smcimp-solution}
# To create the event variable:
pbcdat$event <- as.numeric(pbcdat$status == 'dead')

# specify imputation method (in order of variables in dataset)
meth_smcsurv <- c(time = "", status = "", platelet = "norm",
                  age = "", sex = "", chol = "norm", stage = "podds",
                  event = "")

# impute the data
smcsurv <- smcfcs(originaldata = pbcdat,
                  smtype = "coxph", 
                  smformula = "Surv(time = time, event) ~ platelet + 
                               age + sex + chol + stage",
                  method = meth_smcsurv, numit = 20)


# plots to check convergence
par(mfrow = c(2, 4), mar = c(3.5, 3.5, 1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(smcsurv$smCoefIter)[2]) {
  matplot(t(smcsurv$smCoefIter[, i, ]), type = 'l', ylab = "coefficient", 
          xlab = "iteration")
}

```


When the algorithm has converged, fit the Cox model and pool the results.

```{r smcsurvpool, exercise = TRUE}

```


```{r smcsurvpool-solution, eval = FALSE}
# create mids object or imputationList object
smcsurv_impList <- mitools::imputationList(smcsurv$impDatasets)


smcsurv_models <- with(smcsurv_impList, coxph(Surv(time = time, event) ~ platelet + 
                               age + sex + chol + stage))

smcsurv_mira <- as.mira(smcsurv_models)

summary(pool(smcsurv_mira))
```


### Imputation with **jomo**

To impute the pbc data with the package **jomo** we use the function `jomo.coxph()`,
which works analogously to the other `jomo.<...>()` functions we have seen.

As in the previous examples, we first check the convergence of the algorithm
using `jomo.coxph.MCMCchain()`. Again, we first need to create the event indicator.

```{r jomosurv, exercise = TRUE, exercise.timelimit = 200, fig.width = 9, fig.height = 9}
# create the event indicator
pbcdat$event <- pbcdat$status == 'dead'

jomosurvMCMC <- ...
```

```{r jomosurv-hint-1}
# create the event indicator
pbcdat$event <- pbcdat$status == 'dead'

# run "jomo.coxph.MCMCchain" to check convergence
jomosurvMCMC <- jomo.coxph.MCMCchain(formula = Surv(time, event) ~ platelet + 
                                       age + sex + chol + stage,
                                     data = pbcdat, nburn = 2000)

```


```{r jomosurv-solution}
# create the event indicator
pbcdat$event <- pbcdat$status == 'dead'

# run "jomo.coxph.MCMCchain" to check convergence
jomosurvMCMC <- jomo.coxph.MCMCchain(formula = Surv(time, event) ~ platelet + 
                                       age + sex + chol + stage,
                                     data = pbcdat, nburn = 2000)

# plot the resulting samples
par(mfrow = c(3,3), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomosurvMCMC$collectbeta)[2]) {
  plot(jomosurvMCMC$collectbeta[1, i, ], type = 'l')
}

par(mfrow = c(2,4), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomosurvMCMC$collectbetaY)[2]) {
  plot(jomosurvMCMC$collectbetaY[1, i, ], type = 'l')
}


par(mfrow = c(6, 8), mar = c(3,3,1,1), mgp = c(2, 0.6, 0))
for (i in 1:dim(jomosurvMCMC$collectomega)[2]) {
  for (j in 1:i) {
    plot(jomosurvMCMC$collectomega[i, j , ], type = 'l')
  }
}

```


Once you know how many iterations are necessary for convergence, perform the
imputation, analyse the imputed data and pool the results.

```{r jomosurvrun, exercise = TRUE, exercise.timelimit = 200}


```

```{r jomosurvrun-solution}
jomosurv <- jomo.coxph(formula = Surv(time = time, event) ~ platelet + 
                         age + sex + chol + stage,
                       data = pbcdat, nburn = 2000, nimp = 5)


jomosurv_mids <- as.mids(jomosurv,
                         .id = which(names(jomosurv) == "id"),
                         .imp = which(names(jomosurv) == "Imputation"))

jomosurv_mira <- with(jomosurv_mids, coxph(Surv(time, status == "dead") ~ platelet + 
                                             age + sex + chol + stage))
summary(pool(jomosurv_mira))
```

```{r survres-setup}
opt <- getOption("contrasts")
options(contrasts = rep("contr.treatment", 2))

smcsurv_impList <- mitools::imputationList(smcsurv$impDatasets)


smcsurv_models <- with(smcsurv_impList, coxph(Surv(time = time, event) ~ platelet + 
                               age + sex + chol + stage))

smcsurv_mira <- as.mira(smcsurv_models)


jomosurv_mids <- as.mids(jomosurv,
                         .id = which(names(jomosurv) == "id"),
                         .imp = which(names(jomosurv) == "Imputation"))

jomosurv_mira <- with(jomosurv_mids, coxph(Surv(time, status == "dead") ~ platelet + 
                                             age + sex + chol + stage))

options(contrasts = opt)
```

### Imputation with **mice**
As we have seen in the lecture, the **mice** package provides the function 
`nelsonaalen()` that caluclates the Nelson-Aalen estimator with which the
cumulative Hazard can be approximated.


Calculate the Nelson-Aalen estimate for patient survival in the pbc data and
run the imputation in **mice**:

Note: `nelsonaale` uses the name `status` internally. Since `pbcdat` contains
a variable `status` 
```{r micesurv, exercise = TRUE, exercise.timelimit = 200}

```

```{r micesurv-solution}
pbcdat$event <- as.numeric(pbcdat$status == 'dead')

pbcdat$na <- nelsonaalen(data = subset(pbcdat, select = -c(status)),
                         timevar = "time", 
                         statusvar = "event")

```


```{r survres, exercise = TRUE}
opt <- getOption("contrasts")
options(contrasts = rep("contr.treatment", 2))

survcc <- with(pbcdat, coxph(Surv(time, status == "dead") ~ platelet + 
                                             age + sex + chol + stage))
options(contrasts = opt)

survres <- list(
  # survcc = cbind(survcc$coefficients, confint(survcc)),
  smcfcs = summary(pool(smcsurv_mira))[, c("est", "lo 95", "hi 95")],
  jomo = summary(pool(jomosurv_mira))[, c("est", "lo 95", "hi 95")]
)

survres <- lapply(1:length(survres), function(i){
  x <- as.data.frame(survres[[i]])
  names(x) <- c("est", "lo", "hi")
  x$method <- names(survres)[i]
  x$name <- gsub("sex2", "sexf", rownames(x))
  x
})

survresDF <- do.call(rbind, survres)

ggplot(survresDF, aes(x = method, y = est)) +
  geom_point() +
  geom_errorbar(aes(min = lo, max = hi)) +
  facet_wrap("name", scales = 'free')

```

