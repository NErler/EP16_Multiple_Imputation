---
title: "Multiple imputation with the mice package"
output: 
  # html_document:
  #   code_folding: show
  #   df_print: paged
  #   toc: true
  #   toc_float:
  #     collapsed: false
  #   number_sections: false
  #   theme: spacelab
  #   highlight: tango
  #   includes:
  #     after_body: ../footer.html
  #   css: ../style.css
  #   pandoc_args: [
  #     "--output=Practical_MImice.html"
  #     ]
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r, include = F}
if (names(rmarkdown::metadata$output) == "learnr::tutorial") {
  library(learnr)
  learnr::initialize_tutorial()
  static <- FALSE
}

if (names(rmarkdown::metadata$output) == "html_document") {
  knitr::opts_hooks$set(eval = function(opt) {
    if (any(opt$exercise))
      opt$eval <- opt$include <- FALSE
    
    opt
  })
  
  static <- TRUE
  
  options(width = 100)
}
```


```{r packages, include = FALSE}
library(kableExtra)
library(knitr)
library(JointAI)
library(reshape2)
library(plyr)
library(RColorBrewer)
library(ggplot2)
```


```{r load_data, context="data", include=FALSE}
load("www/NHANES_for_practicals.RData")
NHANES$educ <- as.ordered(NHANES$educ)

source("www/propplot.R")
load("www/imps.RData")

library(mice)
```


## Preface {data-progressive=FALSE}
### R packages

```{r, eval = static, echo = FALSE, results = 'asis'}
cat('In this practical, a number of R packages are used.
If any of them are not installed you can still follow the practical
but will not be able to run all of the code. The packages used (with versions
that were used to generate the solutions) are:')
```
```{r, eval = !static, echo = FALSE, results = 'asis'}
cat('In this practical, a number of R packages are used.
    The names of the packages used (and their version numbers available on this platform) are:')
```

* `mice` (version: `r packageVersion("mice")`)
* `JointAI` (version: `r packageVersion("JointAI")`)
* `reshape2` (version: `r packageVersion("reshape2")`)
* `RColorBrewer` (version: `r packageVersion("RColorBrewer")`)
* `ggplot2` (version: `r packageVersion("RColorBrewer")`)


### Help files
You can find help files for any function by adding a `?` before the name of the 
function.

```{r, eval = !static, results = 'asis', echo = FALSE}
cat("The files might look a bit funny when they are displayed as R output.")
```

Alternatively, you can look up the help pages online at 
[https://www.rdocumentation.org/](https://www.rdocumentation.org/)
or find the whole manual for a package at
[https://cran.r-project.org/web/packages/available_packages_by_name.html](https://cran.r-project.org/web/packages/available_packages_by_name.html)


### Dataset 

For this practical, we will again use the **NHANES** dataset that we have seen in
the previous practical.
```{r, eval = !static, echo = FALSE, results = 'asis'}
cat("In the interactive version of this practical, the data is already loaded
    and the variable `educ` correctly coded as an ordered factor.")
```
```{r, eval = static, echo = FALSE, results = 'asis'}
cat(
'To load this dataset, you can use the command `file.choose()` which opens the
explorer and allows you to navigate to the location of the file
`NHANES_for_practicals.RData` on your computer.
If you know the path to the file, you can also use `load("<path>/NHANES_for_practicals.RData")`.

If you have not followed the first practical or if you re-loaded the NHANES data
you need to re-code the variable `educ` again:'
)
```
```{r, eval = FALSE, echo = static}
NHANES$educ <- as.ordered(NHANES$educ)
```


## Preparing for imputation
### Set-up run {.tabset .tabset-fade .tabset-pills}
Imputation needs to be tailored to the dataset at hand and, hence, using
the function `mice()` well requires several arguments to be specified.
To make the specification easier it is useful to do a dry-run which will
create the default versions of everything that needs to be specified. 

These default settings can then be adapted to our data.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Do the set-up run of `mice()` with the NHANES data without any iterations (`maxit = 0`).

```{r imp0, exercise = TRUE, exercise.setup = "educrecode"}
imp0 <- 
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r imp0-solution, solution = TRUE}
# Note: This command will not produce any output.
library(mice)
imp0 <- mice(NHANES, maxit = 0)
```

### Imputation method {.tabset .tabset-fade .tabset-pills}
There are many imputation methods available in **mice**. You can find the list in
the help page of the 
[`mice()` function](https://www.rdocumentation.org/packages/mice/versions/3.3.0/topics/mice).
We will focus here on the following ones:

```{r, echo = F}
tab <- rbind(
  c("pmm", "any", "Predictive mean matching"),
  # c("midastouch", "any", "Weighted predictive mean matching"),
  # c("sample", "any", "Random sample from observed values"),
  # c("cart", "any", "Classification and regression trees"),
  # c("rf", "any", "Random forest imputations"),
  # c("mean", "numeric", "Unconditional mean imputation"),
  c("norm", "numeric", "Bayesian linear regression"),
  # c("norm.nob", "numeric", "Linear regression ignoring model error"),
  # c("norm.boot", "numeric", "Linear regression using bootstrap"),
  # c("norm.predict", "numeric", "Linear regression, predicted values"),
  # c("quadratic", "numeric", "Imputation of quadratic terms"),
  # c("ri", "numeric", "Random indicator for nonignorable data"),
  c("logreg", "binary", "Logistic regression"),
  # c("logreg.boot", "binary", "Logistic regression with bootstrap"),
  c("polr", "ordered", "Proportional odds model"),
  c("polyreg", "unordered", "Polytomous logistic regression")
  # c("lda", "unordered", "Linear discriminant analysis"),
  # c("2l.norm", "numeric", "Level-1 normal heteroscedastic"),
  # c("2l.lmer", "numeric", "Level-1 normal homoscedastic, lmer"),
  # c("2l.pan", "numeric", "Level-1 normal homoscedastic, pan"),
  # c("2l.bin", "binary", "Level-1 logistic, glmer"),
  # c("2lonly.mean", "numeric", "Level-2 class mean"),
  # c("2lonly.norm", "numeric", "Level-2 class normal"),
  # c("2lonly.pmm", "any", "Level-2 class predictive mean matching")
)

colnames(tab) <- c("name", "variable type", "description")

knitr::kable(tab, row.names = FALSE) %>%
  kable_styling(full_width = FALSE)
  
```

The default imputation methods that `mice()` selects can be specified in the
argument `defaultMethod`. 

If unspecified, `mice` will use 

* `pmm` for numerical columns,
* `logreg` for factor columns with two categories, 
* `polyreg` for columns with unordered and 
* `polr` for columns with ordered factors with more than two categories.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

When a normal imputation model seems to be appropriate for most of the 
continuous covariates, you may want to specify `norm` as
the default method in the setup run. Let's do that:

```{r imp0v2, exercise = TRUE, exercise.setup = "educrecode"}
imp0 <- ...(..., defaultMethod = ...)
```

```{r imp0v2-hint-1, eval = !static, echo = FALSE}
# The order for the types of variables is:
# continuous, binary, factor, ordered factor
```

```{r imp0v2_hint, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#imp0v2">Hint</button>
<div id = "imp0v2" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
The order of the types of variable is: continuous, binary, factor, ordered factor.
</div>')
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```


```{r imp0v2-hint-2, solution = TRUE}
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

In the histograms we made for the continuous variables during the previous practical,
we could see that the variable `creat` had a skewed distribution, hence, 
using a normal imputation model may not work well. 

* Extract the default settings of `meth` from `imp0`.
* Change the imputation method for `creat` so that this variable will be imputed
  using predictive mean matching.
* Check that all specified imputation methods are correct. When no imputation 
  method is specified (`""`) the variable will not be imputed.

```{r changeimpmod-setup, exercise.setup = "educrecode", eval = !static, echo = FALSE}
imp0 <- suppressWarnings(mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
)
```

```{r changeimpmod, exercise = TRUE}
meth <- ...

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r changeimpmod-solution, solution = TRUE}
meth <- imp0$meth
meth["creat"] <- "pmm"
meth
```


### Predictor matrix {.tabset .tabset-fade .tabset-pills}
The predictor matrix specifies which variables are used in the linear predictors
of each of the imputation models. 

A value of `1` specifies that the variable given in the column name is used in the model
to impute the variable given in the row name (and `0` specifies that this variable
is not used in that model).

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Get the `predictorMatrix` from `imp0`. Notice that **mice** has already set
some of the values to `0`. Do you understand why?

```{r predmat-setup, eval = !static, echo = FALSE}
imp0 <- suppressWarnings(
  mice(NHANES, maxit = 0,
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
)
meth <- imp0$meth
meth["creat"] <- "pmm"
```

```{r predmat, exercise = TRUE}
pred <-
pred
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r predmat-solution, solution = TRUE}
pred <- imp0$predictorMatrix
pred
```

```{r, eval = !static, echo = FALSE}
asis_output("### \\n")
```

The column corresponding to the variable `cohort` is set to `0` which means 
that this variable is not used in any of the imputation models.
`cohort` has the same value for all observations, so it would not be useful as a covariate.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Because BMI is calculated from height (`hgt`) and weight (`wgt`), and there are
cases where only one of these two variables is missing, we want to impute 
`hgt` and `wgt` separately. `BMI` should be imputed using "passive imputation".

To avoid multicollinearity (which may lead to problems during imputation),
imputation models should not include all three variables as predictor variables.
In this example, we will use `BMI` to impute the other variables.

Moreover, we need to exclude `WC` from the imputation model for `wgt` because
the high correlation between `WC`, `BMI` and `wgt` would otherwise lead to problems
during imputation.

And since `HyperMed` does not give us a lot more information than `hypten`, but
has a lot more missing values, we do not want to use it as a predictor variable.

Apply the necessary changes to  `pred` and `meth`.
```{r changepred-setup, include = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- suppressWarnings(
  mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
)
meth <- imp0$meth
meth["creat"] <- "pmm"

pred <- imp0$pred
```

```{r changepred, exercise = TRUE}

```

```{r changepred-hint-1, eval = !static, echo = FALSE}
# For passive imputation, you need to specify the formula used to calculate
# BMI in meth using "~I(...)".
```

```{r changepred_hint1, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#changepred">Hint</button>
<div id = "changepred" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
For passive imputation, you need to specify the formula used to calculate BMI in meth using `"~I(...)"`.
</div>')
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r changepred-solution, solution = TRUE}
# BMI will not be used as predictor of height and weight
pred[c("hgt", "wgt"), "BMI"] <- 0
# height and weight will not be used as predictor in any model
pred[, c("hgt", "wgt")] <- 0
# height and weight will be used as predictors for each other
pred["hgt", "wgt"] <- 1
pred["wgt", "hgt"] <- 1

# WC is not used as predictor for weight
pred["wgt", "WC"] <- 0

# HyperMed will not be used as predictor in any model
pred[, "HyperMed"] <- 0

# hypchol will not be used as predictor in the imputation model for chol
pred["chol", "hypchol"] <- 0

# BMI will be imputed passively
meth["BMI"] <- "~I(wgt/hgt^2)"
# HyperMed will not be imputed
meth["HyperMed"] <- ""
```

### Visit sequence {.tabset .tabset-fade .tabset-pills}
The visit sequence specifies the order in which the variables are imputed.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```


To be sure that the imputed values of `BMI` match the imputed values of `hgt`
and `wgt`, `BMI` needs to be imputed after `hgt` and `wgt`.

* Get the `visitSequence` from `imp0`, and
* change it if necessary.

```{r changevisseq-setup, include = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- suppressWarnings(mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
)
meth <- imp0$meth
meth["creat"] <- "pmm"

pred <- imp0$pred
pred[c("hgt", "wgt"), "BMI"] <- 0
pred[, c("hgt", "wgt")] <- 0
pred["hgt", "wgt"] <- 1
pred["wgt", "hgt"] <- 1
pred["wgt", "WC"] <- 0

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0

meth["BMI"] <- "~I(wgt/hgt^2)"
meth["HyperMed"] <- ""
```

```{r changevisseq, exercise = TRUE}
visSeq <- ...
...
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r changevisseq-solution, solution = TRUE}
visSeq <- imp0$visitSequence

# the lazy version:
visSeq <- c(visSeq[-2], visSeq[2])

# the save version:
# To make sure you still do the correct thing if the order of the columns in 
# NHANES would change
which_BMI <- match("BMI", visSeq)
visSeq <- c(visSeq[-which_BMI], visSeq[which_BMI])
```


## Imputation
### Running the imputation  {.tabset .tabset-fade .tabset-pills}
```{r allprep, include = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- suppressWarnings(mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
)
meth <- imp0$meth
meth["creat"] <- "pmm"
meth["HyperMed"] <- ""

pred <- imp0$pred

pred[c("hgt", "wgt"), "BMI"] <- 0
pred[, c("hgt", "wgt")] <- 0
pred["hgt", "wgt"] <- 1
pred["wgt", "hgt"] <- 1
pred["wgt", "WC"] <- 0

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0

meth["BMI"] <- "~I(wgt/hgt^2)"
meth["HyperMed"] <- ""

visSeq <- imp0$visitSequence
which_BMI <- match("BMI", visSeq)
visSeq <- c(visSeq[-which_BMI], visSeq[which_BMI])
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

With the changes that we have made to the `predictorMatrix` and `method`, we
can now perform the imputation. Use `m = 5` and `maxit = 10`.

```{r runimp, exercise = TRUE, exercise.timelimit = 100, exercise.setup = "allprep"}
imp <- 
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r runimp-solution, solution = TRUE, eval = FALSE}
imp <- mice(NHANES, method = meth, predictorMatrix = pred, visitSequence = visSeq,
            maxit = 10, m = 5, seed = 2019)
```

```{r saveimp, include = FALSE, eval = FALSE, cache = TRUE}
savedimps_imp <- mice(NHANES, method = meth, predictorMatrix = pred,
                      visitSequence = visSeq,
                      maxit = 10, m = 5,
                      seed = 2019)

savedimps_imp30 <- mice(NHANES, method = meth, predictorMatrix = pred,
                      visitSequence = visSeq,
                      maxit = 30, m = 5,
                      seed = 2019)

savedimps_impnaive <- mice(NHANES, maxit = 30, m = 5, seed = 2019)

save(savedimps_imp,
     savedimps_imp30,
     savedimps_impnaive, file = "www/imps.RData")
```

`mice()` prints the name of the variable being imputed for each
iteration and imputation. If you run `mice()` on your own computer the output
will show up continuously. There, you may notice that imputation is slowest for 
categorical variables, especially when they have many categories.

You can hide the lengthy output by specifying
`printFlag = FALSE`.

### What does mice return? {.tabset .tabset-fade .tabset-pills}

```{r, eval = static, echo = FALSE}
asis_output("#### Task \\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

`mice()` does not return a `data.frame`. 
Find out the class of the object returned by `mice()` function using the 
function `class()`, and take a look at the [help file](https://www.rdocumentation.org/packages/mice/versions/2.46.0/topics/mids-class) for this class.

```{r allimp, echo = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)

imp0 <- suppressWarnings(mice(NHANES, maxit = 0, 
                              defaultMethod = c("norm", 'logreg', 'polyreg', 'polr')))

meth <- imp0$meth
meth["creat"] <- "pmm"
meth["HyperMed"] <- ""

pred <- imp0$pred

pred[c("hgt", "wgt"), "BMI"] <- 0
pred[, c("hgt", "wgt")] <- 0
pred["hgt", "wgt"] <- 1
pred["wgt", "hgt"] <- 1
pred["wgt", "WC"] <- 0

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0

meth["BMI"] <- "~I(wgt/hgt^2)"
meth["HyperMed"] <- ""

visSeq <- imp0$visitSequence
which_BMI <- match("BMI", visSeq)
visSeq <- c(visSeq[-which_BMI], visSeq[which_BMI])

impnaive <- savedimps_impnaive
imp <- savedimps_imp
```


```{r findclass, exercise = TRUE, exercise.setup = "allimp"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r findclass-solution, solution = TRUE}
class(imp)
```

```{r, echo = FALSE, eval = !static}
asis_output("### \\n")
```

We see that `imp` is an object of class `mids`.

The [help file](https://www.rdocumentation.org/packages/mice/versions/2.46.0/topics/mids-class) tells us that a `mids` object is a list with several elements:

```{r, echo = FALSE}
midsdf <- rbind(
  c("`data`:", "Original (incomplete) data set."),
  c("`imp`:",
    paste0("The imputed values: A list of `ncol(data)` components, ",
           "each list component is a matrix with `nmis[j]` rows and `m` columns.")),
  c("`m`:",
    "The number of imputations."),
  c("`where`:", "The missingness indicator matrix."),
 c("`blocks`", "The blocks argument of the `mice()` function."),  
  c("`call`:", "The call that created the `mids` object."),
  c("`nmis`:",
    "The number of missing observations per variable."),
  c("`method`:",
    "The vector imputation methods."),
  c("`predictorMatrix`:",
    "The predictor matrix."),
  c("`visitSequence`:", 
    "The sequence in which columns are visited during imputation."),
 c("`formulas`", "A named list of formulas corresponding the the imputed variables (blocks)."),
  c("`post`:",
    "A vector of strings of length `length(blocks)` with commands for post-processing."),
 # c("`blots`", ""),
  c("`seed`:",
    "The seed value of the solution."),
  c("`iteration`:", 
    "The number of iterations."),
  c("`lastSeedValue`:",
    "The most recent seed value."),
  c("`chainMean:`", 
    paste0("The mean of imputed values per variable and iteration: ",
           "a list of `m` components. Each component is a matrix with `maxit`",
           "columns and `length(visitSequence)` rows.")),
  c("`chainVar`:",
    paste0("The variances of imputed values per variable and iteration" ,
           "(same structure as `chainMean`).")),
  c("`loggedEvents`:",
    paste0("A `data.frame` with the record of automatic corrective actions and warnings; ",
           "(`NULL` if no action was made).")),
  # c("`pad`:",
  #   paste0("A list containing the internally used version of the `data`,",
  #          "`method`, `predictorMatrix`, `visitSequence`, `post` and dummy coding.")
 c("`version`", "Version number of the **mice** package that created the object."),
 c("`date`", "Date at which the object was created.")
) %>% as.data.frame

names(midsdf) <- c(" ", " ")

midsdf %>% kable(format = 'html') %>%
  kable_styling()
  # row_spec(c(4:10, 12:16), background = "#f2f2f2")
```



**Details of the `loggedEvents`:**

`mice()` does some pre-processing of the data:

  * variables containing missing values, that are not imputed but used as
    predictor are removed
  * constant variables are removed
  * collinear variables are removed
  
  
Furthermore, during each iteration

  * variables (or dummy variables) that are linearly dependent are removed
  * `polr` imputation that does not converge is replaced by `polyreg`. 
  
The `data.frame` in `loggedEvents` has the following columns:
```{r, echo = FALSE}
rbind(
  c("`it`", "iteration number"), 
  c("`im`", "imputation number"),
  c("`dep`", "name of the name of the variable being imputed"),
  c("`meth`", "imputation method used"),
  c("`out`", "character vector with names of altered/removed predictors")
) %>%
  kable(format = "html") %>%
  kable_styling(full_width = FALSE)

```

## Evaluate the imputation
### Checking the settings {.tabset .tabset-fade .tabset-pills}

It is good practice to make sure that `mice()` has not done 
any processing of the data that was not planned or that you are not aware of.
This means checking that the correct `method`, `predictorMatrix` and
`visitSequence` were used.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Do these checks for `imp`.

```{r checkmids, exercise = TRUE, exercise.setup = "allimp"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r checkmids-solution, solution = TRUE}
imp$method
imp$predictorMatrix
imp$visitSequence

# you can also try
# identical(imp$method, meth)
# identical(imp$predictorMatrix, pred)
# identical(imp$visitSequence, visSeq)
```

### Logged events {.tabset .tabset-fade .tabset-pills}
Checkingt the `loggedEvent` shows us if `mice()` detected any problems during
the imputation.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Check the `loggedEvents` for `imp`.

```{r imploggedEvents, exercise = TRUE, exercise.setup = "allimp"}

```


```{r, eval = !static, echo = FALSE}
asis_output("### \\n")
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r imploggedEvents-solution, solution = TRUE}
imp$loggedEvents
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

Let's see what would have happened if we had not prepared the
`predictorMatrix`, `method` and `visitSequence` before imputation.
The object `impnaive` contains the result of 
```{r, eval = FALSE, echo = TRUE, include = TRUE}
impnaive <- mice(NHANES, m = 5, maxit = 30)
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Take a look at the `loggedEvents` of `impnaive`. 

```{r impnaiveloggedEvents, exercise = TRUE, exercise.setup = "allimp"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r impnaiveloggedEvents-solution, solution = TRUE}
impnaive$loggedEvents
```


```{r, eval = !static, echo = FALSE}
asis_output("### \\n")
```


The `loggedEvents` of the "naive" imputation show that the constant variable
`cohort` was excluded before the imputation (as it should be).
Furthermore, in the imputation model for `HyperMed`, the variable `hyptenyes`
was excluded (`hyptenyes` is the dummy variable belonging to `hypten`).

<br>

```{r, eval = static, echo = FALSE}
asis_output("#### Task 3\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

We did not change the `visitSequence` in `impnaive`. Find out how that
affected the imputed values of `BMI`.

```{r impnaiveVisSeq, exercise = TRUE, exercise.setup = "allimp"}

```

```{r impnaiveVisSeq-hint-1, include = !static, echo = FALSE}
# You can get an imputed datasets from a mids object using the function complete().
# Use ?complete for more information.
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 3\\n")
```

```{r, impnaiveVisSeq-solution, solution = TRUE}
naiveDF1 <- complete(impnaive, 1)
naivecalcBMI <- with(naiveDF1, wgt/hgt^2)

impDF1 <- complete(imp, 1)
impcalcBMI <- with(impDF1, wgt/hgt^2)

cbind(naiveBMI = naiveDF1$BMI, naivecalcBMI,
      impBMI = impDF1$BMI, impcalcBMI)[which(is.na(NHANES$BMI)), ]

```

When we compare the imputed and calculated values of `BMI` from `impnaive` we
can see that the imputed `hgt` and `wgt` give a different `BMI` than is
imputed. This is because `BMI` is imputed before `wgt`, which means that the
most recent imputed value of `wgt` is from the previous iteration.

Changing the `visitSequence` in `imp` prevented this inconsistency.


### Convergence {.tabset .tabset-fade .tabset-pills}
In order to obtain correct results, the MICE algorithm needs to have converged.
This can be checked visually by plotting summaries of the imputed values
accross the iterations.

The mean and variance of the imputed values per iteration and variable is
stored in the elements `chainMean` and `chainVar` of the `mids` object.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Plot them to see if our imputation `imp` has converged.

```{r convergence, exercise = TRUE, exercise.setup = "allimp", fig.width = 9, fig.height = 7}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r convergence-solution, solution = TRUE, fig.width = 8.5, fig.height = 7}
# implemented plotting function (use layout to change the number of rows and columns)
plot(imp, layout = c(6, 6))
```

```{r, eval = !static, echo = FALSE}
asis_output("### \\n")
```

The chains in `imp` seem to have converged, however it is difficult to judge this
based on only 10 iterations. In practice, more iterations should be done.


To save you some time, I ran the imputation again with 30 iterations and the
traceplots confirm convergence:
```{r, echo = FALSE}
imp30 <- savedimps_imp30
impnaive <- savedimps_impnaive
```

```{r, fig.width = 9, fig.height = 7}
plot(imp30, layout = c(6, 6))
```



```{r, eval = static, echo = FALSE}
asis_output("#### Continue\\n")
```

In comparison, `impnaive` had some convergence problems:
```{r, fig.width = 9, fig.height = 7}
plot(impnaive, layout = c(6, 6))
```


`hgt`, and `wgt` show a clear trend and the chains do not mix well, i.e., there
is more variation between the chains than within each chain.
(the same is the case for `BMI`).

These are clear signs that there is correlation or identification
problems between these variables and some other variables (which is why we made
adjustments to the `predictorMatrix` for `imp`).

### Imputed values {.tabset .tabset-fade .tabset-pills}
Now that we know that `imp` has converged, we can compare the distribution of
the imputed values against the distribution of the observed values.
When our imputation models fitted the data well, they should have similar
distributions (conditional on the covariates used in the imputation model).

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1 \\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

* Plot the distributions of the imputed variables (continuous and categorical).
* Make sure the imputed values are realistic (e.g., height of 2.50m or weight of 10kg for adults).

```{r distrplot, exercise = TRUE, exercise.setup = "allimp", fig.width = 9, fig.height = 7}

```

```{r impdistrhint, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#impdistrhint">Hint 1</button>
<div id = "impdistrhint" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
You can use `densityplot()` and `propplot()` to get plots for all continuous and
categorical variables.

`propplot()` is not part of any package. Copy the following syntax that defines
this function:

<script src="https://gist.github.com/NErler/0d00375da460dd33839b98faeee2fdab.js"></script>

</div>')
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#impdistrhint2">Hint 2</button>
<div id = "impdistrhint2" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
To check all imputed values you can either get a summary of the `imp` element
of the `mids` object or create a complete dataset containing all imputations
using the function `complete()` and get the summary of that.
</div>')
```

```{r distrplot-hint-1, include = !static, echo = FALSE}
# You can use "densityplot()" and "propplot()" to get plots for all continuous and
# categorical variables.
# 
# The function "propplot() is not part of any package but can be found online:
# https://gist.github.com/NErler/0d00375da460dd33839b98faeee2fdab
# 
# In this practical it is available automatically.
# 
# To check all imputed values you can either get a summary of the "imp" element
# of the mids object or create a complete dataset containing all imputations
# using the function "complete()" and get the summary of that.
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```


```{r distrplot-solution, solution = TRUE, fig.width = 9, fig.height = 7, cache = TRUE}
# plot densities of continuous variables
densityplot(imp)


# plot for all categorical variables
propplot(imp)

# get the summary of the "the" imputed values
sapply(Filter(function(x) nrow(x) > 0, imp$imp),
       function(x) summary(unlist(x))
)
```

```{r, eval = !static, echo = FALSE}
asis_output("### \\n")
```

Unfortunately, we have some negative imputed values for `bili`. Often, this
would not result in bias in the analysis, but may be difficult to explain
when providing a summary of the imputed data in a publication.
In the present example we can see that the observed values have a slightly
right-skewed distribution compared to the imputed values. Re-doing the
imputation with `pmm` instead of `norm` for `bili` should fix this.
(However, since the imputations seem fine overall, and there is little knowledge
gain in re-doing the previous steps, we will skip this repetition 
in this practical.)

The distributions of the imputed values for `hgt` and `SBP` differ a bit
from the distributions of the observed data.

We also imputed a larger proportion than might have been expected in the 
highest category of `alc`, and the distribution of values for `smoke`
looks a bit weird (but `smoke` only has one missing value, which makes it difficult
to judge the distribution of the imputed values).

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2 \\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```


Investigate if differences in the distributions of observed and imputed values,
can be explained by other variables. Check this for

* `SBP` conditional on `gender` and `hypten`
* `hgt` conditional on `gender`
* `alc` conditional on `gender` or `smoke`


```{r distrplot2, exercise = TRUE, exercise.setup = "allimp", fig.width = 9, fig.height = 7}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```


```{r distrplot2-solution, solution = TRUE, fig.width = 8, fig.height = 6, cache = TRUE}
densityplot(imp, ~SBP|hypten + gender)
densityplot(imp, ~hgt|gender)

propplot(imp, alc ~ gender + smoke)
```


