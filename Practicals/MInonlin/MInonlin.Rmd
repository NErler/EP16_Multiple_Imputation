---
title: "Imputation of Data with Non-linear Associations"
output: 
  html_document:
    code_folding: show
    df_print: paged
    toc: true
    toc_float:
      collapsed: false
    number_sections: false
    theme: spacelab
    highlight: tango
    includes:
      after_body: ../footer.html
    css: ../style.css
#   learnr::tutorial:
#     progressive: true
#     allow_skip: true
# runtime: shiny_prerendered
---

```{r, include = FALSE}

runimps <- FALSE

if (names(rmarkdown::metadata$output) == "learnr::tutorial") {
  library(learnr)
  learnr::initialize_tutorial()
  static <- FALSE
}

if (names(rmarkdown::metadata$output) == "html_document") {
  knitr::opts_hooks$set(eval = function(opt) {
    if (any(opt$exercise))
      opt$eval <- opt$include <- FALSE
    
    opt
  })
  
  static <- TRUE
  
  options(width = 100)
}
```


```{r packages, include = FALSE}
library(kableExtra)
library(knitr)
library(JointAI)
library(ggplot2)
```


```{r load_data, context="data", include=FALSE}
load("www/NHANES_for_practicals_2.RData")

source("www/propplot.R")
load("www/imps_nonlin.RData")

library(mice)
```


## Preface {data-progressive=FALSE}
### R packages

```{r, eval = static, echo = FALSE, results = 'asis'}
cat('In this practical, a number of R packages are used.
If any of them are not installed you can still follow the practical
but will not be able to run all of the code. The packages used (with versions
that were used to generate the solutions) are:')
```
```{r, eval = !static, echo = FALSE, results = 'asis'}
cat('In this practical, a number of R packages are used.
    The names of the packages used (and their version numbers available on this platform) are:')
```

* `mice` (version: `r packageVersion("mice")`)
* `JointAI` (version: `r packageVersion("JointAI")`)
* `ggplot2` (version: `r packageVersion("ggplot2")`)
* `reshape2` (version: `r packageVersion("reshape2")`)


### Help files
You can find help files for any function by adding a `?` before the name of the 
function.
```{r, eval = !static, results = 'asis', echo = FALSE}
cat("The files might look a bit funny when they are displayed as R output.")
```

Alternatively, you can look up the help pages online at 
[https://www.rdocumentation.org/](https://www.rdocumentation.org/)
or find the whole manual for a package at
[https://cran.r-project.org/web/packages/available_packages_by_name.html](https://cran.r-project.org/web/packages/available_packages_by_name.html)


### Dataset 

For this practical, we will use a subset of the **NHANES** dataset that we have
seen in the previous practicals. It contains only those cases that have
observed `wgt` and some columns that are not needed were excluded.
```{r, eval = !static, echo = FALSE, results = 'asis'}
cat("In the interactive version of this practical, the data is already loaded
    and the variable `educ` correctly coded as an ordered factor.")
```
```{r, eval = static, echo = FALSE, results = 'asis'}
cat(
'To load this dataset, you can use the command `file.choose()` which opens the
explorer and allows you to navigate to the location of the file
`NHANES_for_practicals_2.RData` on your computer.
If you know the path to the file, you can also use `load("<path>/NHANES_for_practicals_2.RData")`.'
)
```

### Aim
The focus of this practical is the imputation of data that has features
that require special attention.

In the interest of time, we will focus on these features and **abbreviate steps
that are the same as in any imputation setting** (e.g., getting to know 
the data or checking that imputed values are realistic).
**Nevertheless, these steps are of course required when analysing data in 
practice.**


Our aim is to fit the following **linear regression model for weight**:
```{r NHANESmodel, eval = FALSE}
mod <- lm(wgt ~ gender + bili + age * (chol + HDL) + hgt)
```

We expect that the effects of cholesterol and HDL may differ with age, and, 
hence, include **interaction terms** between `age` and `chol` and `HDL`,
respectively.

Additionally, we want to include the other variables in the dataset as auxiliary variables.

## Imputation using **mice**
When the analysis model of interest involves interaction terms between
incomplete variables, **mice** has limited options to reduce the bias that may
be introduced by naive handling of the missing values.


Use of the "Just Another Variable" approach can in some settings reduce bias.
Alternatively, we can use passive imputation, i.e.,
calculate the interaction terms in each iteration of the MICE algorithm.
Furthermore, predictive mean matching tends to lead to less bias than 
normal imputation models.

### Just Another Variable approach {.tabset .tabset-fade .tabset-pills}
```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

* Calculate the interaction terms in the incomplete data,  and
* perform the setup-run of `mice()` without any iterations.

```{r miceJAVsetup, exercise = TRUE, exercise.timelimit = 200}

```

```{r miceJAVsetup-hint-1, include = !static}
# calculate the interaction terms
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL
```


```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r miceJAVsetup-solution}
# calculate the interaction terms
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL

# setup run
imp0 <- mice(NHANES, maxit = 0, defaultMethod = c('norm', 'logreg', 'polyreg', 'polr'))
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Apply the necessary change to the imputation method and predictor matrix.
```{r miceJAVchanges-setup, eval = !static, include = !static}
# calculate the interaction terms
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL

# setup run
imp0 <- mice(NHANES, maxit = 0, defaultMethod = c('norm', 'logreg', 'polyreg', 'polr'))

```

```{r miceJAVchanges, exercise = TRUE}
meth <- ...
pred <- ...

...
```

```{r, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#JAVhint">Hint</button>
<div id = "JAVhint" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
Since the interaction terms are calculated from the orignal variables,
these interaction terms should not be used to impute the original variables.
</div>')
```

```{r miceJAVchanges-hint-1, include = !static}
# Since the interaction terms are calculated from the orignal variables,
# these interaction terms should not be used to impute the original variables.
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r, miceJAVchanges-solution}
meth <- imp0$method 
pred <- imp0$predictorMatrix

# change imputation for "bili" to pmm (to prevent negative values)
meth["bili"] <- 'pmm'
 
# changes in predictor matrix to prevent that the original variables are
# imputed based on the interaction terms
pred["chol", "agechol"] <- 0
pred["HDL", "ageHDL"] <- 0
```


```{r, eval = static, echo = FALSE}
asis_output("#### Task 3\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```
Run the imputation using the **JAV approach**.

```{r, include = !static, echo = FALSE}
asis_output("(For each of the two approaches 10 iterations of 5 imputed datasets take approx. 30 seconds.)")
```

```{r miceJAV-setup, eval = !static, include = !static}
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL

imp0 <- mice(NHANES, maxit = 0, defaultMethod = c('norm', 'logreg', 'polyreg', 'polr'))

meth <- imp0$method 
pred <- imp0$predictorMatrix

# change imputation for "bili" to pmm (to prevent negative values)
meth["bili"] <- 'pmm'
 
# changes in predictor matrix to prevent that the original variables are
# imputed based on the interaction terms
pred["chol", "agechol"] <- 0
pred["HDL", "ageHDL"] <- 0
```

```{r miceJAV, exercise = TRUE, exercise.timelimit = 200}
impJAV <- ...
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 3\\n")
```

```{r miceJAV-solution, eval = FALSE}
# run imputation with the JAV approach
impJAV <- mice(NHANES, method = meth, predictorMatrix = pred,
                maxit = 10, m = 5)
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 4\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

We skip the evaluation of convergence and investigation of the imputed values.
With the settings given in the solution the chains have converged and distributions
of the imputed values match the distributions of the observed data close enough.

* Analyse the imputed data and pool the results.

```{r miceJAV-analysis-setup, eval = !static, include = !static}
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL

imp0 <- mice(NHANES, maxit = 0)

meth <- imp0$method 
pred <- imp0$predictorMatrix

# change the imputation method
meth["DBP"] <- "norm"
meth <- gsub("pmm", "midastouch", meth)

# changes in predictor matrix
pred["chol", "agechol"] <- 0
pred["HDL", "ageHDL"] <- 0

impJAV <- savedimps_impJAV
```

```{r, echo = FALSE, eval = static}
impJAV <- savedimps_impJAV
```


```{r miceJAV-analysis, exercise = TRUE}


```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 4\\n")
```

```{r miceJAV-analysis-solution}
miraJAV <- with(impJAV, 
                lm(wgt  ~ gender + bili + age + chol + HDL + agechol + ageHDL + hgt))
summary(pool(miraJAV), conf.int = TRUE)
```


### Passive Imputation {.tabset .tabset-fade .tabset-pills}
For the passive imputation, we can re-use the adjusted versions of `meth` and 
`pred` we created for the JAV approach, but additional changes to `meth`
are necessary.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Specify the new imputation method, i.e., adapt `meth` and save it as `methPAS`.

```{r, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#PAShint">Hint</button>
<div id = "PAShint" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
For passive imputation instead of an imputation method you need to specify the formula used to calculate the value that is imputed passively.
</div>')
```

```{r micePASchanges-setup, eval = !static, include = !static}
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL

imp0 <- mice(NHANES, maxit = 0, defaultMethod = c('norm', 'logreg', 'polyreg', 'polr'))

meth <- imp0$method 
pred <- imp0$predictorMatrix

# change imputation for "bili" to pmm (to prevent negative values)
meth["bili"] <- 'pmm'
 
# changes in predictor matrix to prevent that the original variables are
# imputed based on the interaction terms
pred["chol", "agechol"] <- 0
pred["HDL", "ageHDL"] <- 0
```

```{r micePASchanges, exercise = TRUE, exercise.timelimit = 200}
methPAS <- meth
...
```

```{r micePASchanges-hint-1, include = !static}
# For passive imputation instead of an imputation method you need to specify 
# the formula used to calculate the value that is imputed passively.
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r micePASchanges-solution, cache = TRUE}
# changes in imputation method for passive imputation
methPAS <- meth
methPAS[c("agechol", "ageHDL")] <- c("~I(age*chol)", "~I(age*HDL)")
```


```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```
Run the imputation.

```{r micePAS-setup, eval = !static, include = !static}
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL

imp0 <- mice(NHANES, maxit = 0, defaultMethod = c('norm', 'logreg', 'polyreg', 'polr'))

meth <- imp0$method 
pred <- imp0$predictorMatrix

# change imputation for "bili" to pmm (to prevent negative values)
meth["bili"] <- 'pmm'
 
# changes in predictor matrix to prevent that the original variables are
# imputed based on the interaction terms
pred["chol", "agechol"] <- 0
pred["HDL", "ageHDL"] <- 0

methPAS <- meth
methPAS[c("agechol", "ageHDL")] <- c("~I(age*chol)", "~I(age*HDL)")
```

```{r micePAS, exercise = TRUE}
impPAS <- ...

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r micePAS-solution, eval = FALSE}
# run imputation with passive imputation
impPAS <- mice(NHANES, method = methPAS, predictorMatrix = pred,
                maxit = 10, m = 5)
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 3\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

We will again skip evaluation of convergence and investigation of the imputed values.

* Analyse the imputed data and pool the results.

```{r micePASanalysis-setup, eval = !static, include = !static}
NHANES$agechol <- NHANES$age * NHANES$chol
NHANES$ageHDL <- NHANES$age * NHANES$HDL

imp0 <- mice(NHANES, maxit = 0)

meth <- imp0$method 
pred <- imp0$predictorMatrix

# change the imputation method
meth["DBP"] <- "norm"
meth <- gsub("pmm", "midastouch", meth)

# changes in predictor matrix
pred["chol", "agechol"] <- 0
pred["HDL", "ageHDL"] <- 0

# changs in imputation method for passive imputation
methPAS <- meth
methPAS[c("agechol", "ageHDL")] <- c("~I(age*chol)", "~I(age*HDL)")

impPAS <- savedimps_impPAS
```

```{r micePASanalysis, exercise = TRUE}


```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 3\\n")
```

```{r, echo = FALSE, eval = static}
impPAS <- savedimps_impPAS
```

```{r micePASanalysis-solution}
miraPAS <- with(impPAS, 
                lm(wgt ~ gender + bili + age + chol + HDL + agechol + ageHDL + hgt))

summary(pool(miraPAS), conf.int = TRUE)
```


```{r saveimp, include = FALSE, eval = runimps}
savedimps_impJAV <- mice(NHANES, method = meth, predictorMatrix = pred,
                maxit = 10, m = 5)

savedimps_impPAS <- mice(NHANES, method = methPAS, predictorMatrix = pred,
                         maxit = 10, m = 5)

savedimps_JointAI <- lm_imp(wgt ~ gender + bili + age * (chol + HDL) + hgt, data = NHANES,
                            auxvars = c('educ', 'race', 'SBP', 'hypten', 'WC'),
                            models = c(bili = 'lognorm'), refcats = 'largest',
                            n.iter = 100, seed = 2019)

save(savedimps_impJAV,
     savedimps_impPAS,
     savedimps_JointAI, file = "www/imps_nonlin.RData")
```

## Imputation with **JointAI**
**JointAI** provides functions that allow to fit Bayesian regression models
with incomplete covariates. The main functions are designed to resemble the 
standard functions to fit regression models with complete data.

For univariate outcomes the following functions are available:

* `lm_imp()`: for linear regression
* `glm_imp()`: for generalized linear regression (e.g., logistic, Gamma or Poisson)
* `clm_imp()`: for ordinal (cumulative logit) regression

### Specification of the analysis model {.tabset .tabset-fade .tabset-pills}
Similar to the complete data versions, the functions from **JointAI** take
the following arguments:
```{r JointAIargs, echo = FALSE}
JointAIargs <- rbind(
  c("`formula`", "model formula"),
  c("`data`", "original, incomplete dataset"),
  c("`family`", "for glm's: the distribution family of the outcome (e.g., binomial() for a logistic model)")
) %>% as.data.frame

names(JointAIargs) <- c("", "")

JointAIargs %>% kable(format = 'html') %>%
  kable_styling(full_width = FALSE)
```



```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Specify the linear regression model with the model formula given above using `lm_imp()`.
You need to specify the arguments `formula`, `data` and `n.iter`.
Set `n.iter = 100` (we will learn about this argument further down).
```{r JointAIsetup, exercise = TRUE, exercise.timelimit = 500}
lm1 <- ...
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r JointAIsetup-solution, cache = TRUE}
lm1 <- lm_imp(wgt ~ gender + bili + age * (chol + HDL) + hgt, data = NHANES,
               n.iter = 100)
```


```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

The result is an object of class `JointAI`, which contains  the original data (`data`),
information on the type of model (`call`, `analysis_type`, `models`,
`fixed`, `random`, `hyperpars`, `scale_pars`)
and MCMC sampling (`mcmc_settings`),
the JAGS model (`model`) and MCMC sample (`MCMC`; if a sample was 
generated), the computational time (`time`)
of the MCMC sampling, and some additional
elements that are used by methods for objects of class `JointAI`
but are typically not of interest for the user.

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Check which imputation models were used in `lm1`.

```{r lm1models, exercise = TRUE, exercise.setup = "JointAIsetup-solution"}

```

```{r lm1modelshint, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#lm1modelshint">Hint</button>
<div id = "lm1modelshint" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
The imputation model types are returned in the JointAI object under "models".
</div>')
```

```{r lm1models-hint-1, include = !static, echo = FALSE}
# The imputation model types are returned in the JointAI object under "models".
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r lm1models-solution}
lm1$models
```

### Specification of the imputation models {.tabset .tabset-fade .tabset-pills}
Moreover, there are some arguments related to the imputation part of the model:
```{r JointAIargs2, echo = FALSE}
JointAIargs <- rbind(
  c("`models`", paste0("vector of imputation methods (for details see below and",
                       " the vignette on [Model Specification](https://nerler.github.io/JointAI/articles/ModelSpecification.html#meth))")),
  c("`auxvars`", paste0("vector of names of variables that are not part of the analysis",
                        " model but should be used to predict missing values (optional;",
                        " for details see the vignette on [Model Specification](https://nerler.github.io/JointAI/articles/ModelSpecification.html#auxvars))")),
  c("`refcats`", paste0("allows to specify which category of categorical variables is used as reference (optional;",
                        " for details see the vignette on [Model Specification](https://nerler.github.io/JointAI/articles/ModelSpecification.html#reference-values-for-categorical-covariates))")),
  c("`trunc`", paste0("allows to truncate distributions of incomplete continuous",
   " covariates (for details see the vignette on [Model Specification](https://nerler.github.io/JointAI/articles/ModelSpecification.html#functions-with-restricted-support))"))
) %>% as.data.frame

names(JointAIargs) <- c("", "")

JointAIargs %>% kable(format = 'html') %>%
  kable_styling(full_width = FALSE)

```

Like in **mice** default imputation models are chosen based on the `class` of
each of the incompete variables.
The default choices for baseline (not time-varying) covariates are
```{r, echo = FALSE}
tab <- rbind(norm = c("linear regression", "continuous variables"),
             logit = c("logistic regression", "factors with two levels"),
             multilogit = c("multinomial logit model", "unordered factors with >2 levels"),
             cumlogit = c("cumulative logit model", "ordered factors with >2 levels")
)

tab <- cbind(paste0("`", rownames(tab), "`"), tab)
colnames(tab) <- c('name', 'model', 'variable type')

knitr::kable(tab, row.names = FALSE, format = 'html') %>%
  kable_styling(full_width = FALSE)
```

Alternative imputation methods are available for continuous baseline covariates:
```{r, echo = FALSE}
tab = rbind(lognorm = c("normal regression of the log-transformed variable",
                        "right-skewed variables >0"),
            gamma = c("Gamma regression (with log-link)",
                        "right-skewed variables >0"),
            beta = c("beta regression (with logit-link)",
                     "continuous variables with values in [0, 1]")
)
tab <- cbind(paste0("`", rownames(tab), "`"), tab)
colnames(tab) <- c('name', 'model', 'variable type')

knitr::kable(tab, row.names = FALSE, format = 'html') %>%
  kable_styling(full_width = FALSE)
```


```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Re-fit the linear regression model, but now

* specify a log-normal or a gamma distribution for `bili`
* set the reference category to the largest group
* use the other variables that are in the data as auxiliary variables

```{r JointAIlm2, exercise = TRUE, exercise.timelimit = 500}
lm2 <- ...
```


```{r lm2hints, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#lm2hint1">Hint 1</button>
<div id = "lm2hint1" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
To specify a non-default imputation method use the argument `models = c(bili = ...)`.
</div>')
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#lm2hint2">Hint 2</button>
<div id = "lm2hint2" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
To set the respective largest group as reference category for all categorical variables use the argument `refcats = "largest"`.
</div>')
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#lm2hint3">Hint 3</button>
<div id = "lm2hint3" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
Auxiliary variables need to be specified explicitely using the argument `auxvars`. It takes a vector of variable names (each of them in quotes).
</div>')
```

```{r JointAIlm2-hint-1, include = !static}
# To specify a non-default imputation method use the argument `models = c(bili = ...)`.
```

```{r JointAIlm2-hint-2, include = !static}
# To set the respective largest group as reference category for all categorical variables use the argument `refcats = "largest"`.
```

```{r JointAIlm2-hint-3, include = !static}
# Auxiliary variables need to be specified explicitely using the argument `auxvars`. It takes a vector of variable names (each of them in quotes).
```


```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r JointAIlm2-solution, cache = TRUE}
lm2 <- lm_imp(wgt ~ gender + bili + age * (chol + HDL) + hgt, data = NHANES,
               auxvars = c('educ', 'race', 'SBP', 'hypten', 'WC'),
               models = c(bili = 'lognorm'), refcats = 'largest',
               n.iter = 100)
```


### Specification of the MCMC settings {.tabset .tabset-fade .tabset-pills}
Specification of the basic settings for the MCMC sampling can be achieved using
the following arguments:
```{r JointAIargs3, echo = FALSE}
JointAIargs <- rbind(
  c("`n.chains`", "number of MCMC chains"),
  c("`n.adapt`", "number of iterations used in the adaptive phase"),
  c("`n.iter`", "number of iterations per MCMC chain in the sampling phase")
) %>% as.data.frame

names(JointAIargs) <- c("", "")

JointAIargs %>% kable(format = 'html') %>%
  kable_styling(full_width = FALSE)
```

**JointAI** has more arguments than the ones given above, but in this practical
we focus only on the most important. 
You may find out more about all the arguments in the vignette on [MCMC Settings](https://nerler.github.io/JointAI/articles/MCMCsettings.html).

By default, `n.chains = 3`, `n.adapt = 100` and `n.iter = 0`.

It is usefull to use more than one chain to be able
to evaluate convergence of the MCMC chains.

Samples in the adaptive phase are not used for the final MCMC sample. They are
needed to optimize the MCMC sampler. When the number provided via the argument
`n.adapt` is insufficient for this optimization a warning message will be printed.
In simple models (e.g., linear regression) usually the default value of `n.adapt = 100`
can be used.

The default value for `n.iter`, the number of iterations in the sampling phase
is `0` (no MCMC sample will be created). The number of iterations that is needed
depends on how complex the model and the data is and can range from somewhere
as low as 100 up to several million.

In the following we will look at some criteria to determine if the number of 
MCMC samples that was used is sufficient.


### Evaluation of the MCMC sample {.tabset .tabset-fade .tabset-pills}
The first step after fitting a Bayesian model should be to confirm that
the MCMC chains have converged. This can be done visually, using a traceplot
(plotting the sampled values per parameter and chain accross iterations)
or using the Gelman-Rubin criterion. 

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Investigate convergence of `lm2` by creating a traceplot using the function `traceplot()`.

The plot should show a horizontal band without trends or patterns and the 
different chains should be mixed.

```{r loadlm2, echo = FALSE}
lm2 <- savedimps_JointAI
```

```{r lm2trace, exercise = TRUE, exercise.setup = "loadlm2"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r lm2trace-solution, fig.width = 8, fig.height = 6, out.width = "100%"}
traceplot(lm2)
```


```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Investigate convergence of `lm2` using the Gelman-Rubin criterion, implemented
in the function `GR_crit()`.

The upper limit of the confidenceinterval should not be much larger than 1.
```{r lm2GR, exercise = TRUE, exercise.setup = "loadlm2"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r lm2GR-solution, fig.width = 7, fig.height = 5}
GR_crit(lm2)
```

```{r, eval = static, echo = FALSE}
asis_output("#### Coninue\\n")
```

When we are satisfied with the convergence of the MCMC chains we can take a look
at the MCMC sample is precise enough. We can do this by comparing the Monte Carlo
error (which describes the error made since we have just a finite sample)
to the estimated standard deviation.

This is implemented in the function `MC_error()`.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 3\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Calculate the Monte Carlo error for `lm2`.

```{r lm2MCE, exercise = TRUE, exercise.setup = "loadlm2"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 3\\n")
```

```{r lm2MCE-solution, fig.width = 7, fig.height = 5}
MC_error(lm2)

par(mar = c(3.2, 5, 1, 1), mgp = c(2, 0.6, 0))
plot(MC_error(lm2))
```

### Results {.tabset .tabset-fade .tabset-pills}

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Get the summary of the model using the function `summary()`.

```{r lm2results, exercise = TRUE}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r lm2results-solution, fig.width = 8, fig.height = 6, out.width = "100%"}
summary(lm2)
```


```{r, fig.width = 8, fig.height = 6, out.width = "100%"}
resdat <- lapply(list(
  JAV = summary(pool(miraJAV), conf.int = TRUE)[, c('estimate', '2.5 %', '97.5 %')],
  passive = summary(pool(miraPAS), conf.int = TRUE)[, c('estimate', '2.5 %', '97.5 %')],
  JointAI = as.data.frame(summary(lm2)$stat[names(coef(lm2)), c(1, 3, 4)])
), function(x) {
  colnames(x) <- c('est', 'lo',  'up')
  x$variable <- gsub(":", "", rownames(x))
  x
  })


ggplot(reshape2::melt(resdat, id.vars = c('est', 'lo', 'up', 'variable')),
       aes(x = L1, y = est)) +
  geom_point() +
  geom_errorbar(aes(ymin = lo, ymax = up), width = 0.2) +
  facet_wrap('variable', scales = 'free') +
  xlab("") +
  ylab("estimate & 95% CI")

```

