---
title: "Multiple Imputation with the mice package"
output: 
  html_document:
    code_folding: show
    df_print: paged
    toc: true
    toc_float:
      collapsed: false
    number_sections: false
    theme: spacelab
    highlight: tango
    pandoc_args: [
      "--output=Practical_MICE.html"
      ]
editor_options:
  chunk_output_type: inline
  # learnr::tutorial:
  #   progressive: true
  #   allow_skip: true
# runtime: shiny_prerendered
---

```{r, include = F}
if (names(rmarkdown::metadata$output) == "learnr::tutorial") {
  library(learnr)
  learnr::initialize_tutorial()
  static <- FALSE
}

if (names(rmarkdown::metadata$output) == "html_document") {
  knitr::opts_hooks$set(eval = function(opt) {
    if (any(opt$exercise))
      opt$eval <- opt$include <- FALSE
    
    opt
  })
  
  static <- TRUE
}
```


```{r packages, include = FALSE}
library(ggplot2)
library(JointAI)
library(kableExtra)
library(knitr)
library(miceadds)
library(mitools)
library(magrittr)
library(mice)
library(nlme)
library(plyr)
library(RColorBrewer)
library(reshape2)
library(VIM)
library(visdat)
```


```{r load_data, context="data", include=FALSE}
# load("data/NHANES.RData")
# 
# set.seed(2018)
# sub <- sample(nrow(NHANES), 1000, prob = c(2/3, 1/3)[as.numeric(complete.cases(NHANES)) + 1])
# NHANES <- NHANES[sub, ]
# NHANES$cohort <- "2011"
# NHANES <- NHANES[, sample(ncol(NHANES))]
# save(NHANES, file = "Practicals/MICE/www/NHANES_1.RData")

load("www/NHANES_1.RData")

micemeths <- read.csv2(file = "www/micefunctions.csv")
names(micemeths) <- gsub("vartype", "variable type", names(micemeths))


load("www/imps.RData")
source("www/probplot.R")
```

## Getting to know the data

The first steps are to load the package `mice` and the data we want to impute.
For this example, we will use the **NHANES** dataset.
```{r, eval = !static, echo = FALSE, results = 'asis'}
cat("In the interactive version
of this practical, the data is already loaded. ")
```


```{r, eval = static, echo = FALSE, results = 'asis'}
cat(
# <p style="border:1px; border-style:solid; padding: 1em; border-color:#D11450">
# **Note:**
'To load this dataset, you can use the command `file.choose()` which opens the
explorer and allows you to navigate to the location of the file `NHANES_1.RData`. If you
know the path to the file, you can also use `load("<path>/NHANES_1.RData")`.'
# </p>
)
```


<div style="border:1px; border-style:solid; padding: 1em; border-color:#D11450">
**Note:**<br>
To display the help file for any function, type a `?` followed by the name of the
function in one of the code fields and click on "Run Code".

```{r, eval = !static, results = 'asis', echo = FALSE}
cat("The files might look a bit funny when they are displayed as R output.")
```

Alternatively, you can look up the help pages online at 
[https://www.rdocumentation.org/](https://www.rdocumentation.org/)
or find the whole manual for a package at
[https://cran.r-project.org/web/packages/available_packages_by_name.html](https://cran.r-project.org/web/packages/available_packages_by_name.html)
</div>

### Dataset {.tabset .tabset-fade .tabset-pills}
```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

The **mice** package needs to be loaded with the command `library()`.
Let's take a first look at the data. Useful functions are
`dim()`, `head()`, `str()` and `summary()`.

```{r load-mice, exercise = TRUE}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r load-mice-solution, solution = TRUE}
library(mice)
dim(NHANES)
head(NHANES)
str(NHANES)
summary(NHANES)
```


### Variable coding {.tabset .tabset-fade .tabset-pills}
It is important to check that all variables are coded correctly, i.e., have
the correct variable `class` specified, because `mice()` automatically selects
imputation methods based on each variable's `class`.
When importing data from other
software it can happen that factors become continuous variables or that 
ordered factors lose their ordering.

`str()` showed that in the NHANES data `smoke` and `alc` are correctly specified
as ordinal variables, but `educ` is an unordered factor.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Using `levels(NHANES$educ)` we can print the names of the categories of `educ`.
Convert the unordered factor to an ordered factor, for example using `as.ordered()`.
Afterwards, check if the conversion was successful.
```{r ordered_educ, exercise = TRUE}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r ordered_educ-solution, solution = TRUE}
levels(NHANES$educ)

NHANES$educ <- as.ordered(NHANES$educ)

str(NHANES$educ)
```

```{r educrecode, echo = F}
NHANES$educ <- as.ordered(NHANES$educ)
```

### Missing data pattern {.tabset .tabset-fade .tabset-pills}
In the `summary()` we could already see that there are missing values in several
variables. The function `md.pattern()` allows us to further investigate the 
missing data pattern.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

```{r, eval = static, echo = FALSE}
asis_output("Explore the missing data pattern of the NHANES data.")
```


```{r md-pattern, exercise = TRUE, exercise.setup = "educrecode"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r md-pattern-solution, solution = TRUE}
mdp <- md.pattern(NHANES)
mdp
```


```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

`md.pattern()` gives us a matrix where each row represents one missing data
pattern (1 = observed, 0 = missing).
The rownames show how many rows of the data have the given
missing data pattern. The last column gives the number of missing values in the
pattern, the last row the number of missing values per variable.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Visualize and inspect the missing data pattern using one or more of the
examples shown in the course slides.

```{r vis-mdpattern, exercise = TRUE, fig.width = 8, fig.height = 6}

```

```{r, echo = F, results = 'asis'}
if (static) {
  cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#vismdpat">Hint</button>
<div id = "vismdpat" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
')
} else {
  cat('<div id = "vis-mdpattern-hint">')
}
```

**Hint:**
Some functions you can try are
`JointAI::md_pattern()`,
`VIM::aggr()`,
`visdat::vis_dat()`,
`visdat::vis_miss()`.

For `JointAI::md_pattern()` you can customize the y-axis by using the
argument `yaxis_pars`, which is a list of arguments.
To hide the counts use `yaxis_pars = list(yaxt = "n")` and `printN = FALSE`.
To prevent the printed output use `print = FALSE`.

For more options check out the help pages of the functions.
</div>

```{r echo = FALSE, eval = static}
asis_output("</div>")
```

<br>

```{r, eval = static, echo = FALSE}
asis_output("#### Task 3\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Now get an overview of how much missingness there is in each variable and the
proportion of (in)complete cases.
```{r misprop, exercise = TRUE}

```

```{r misprop-hint-1, eval = !static, include = !static}
# The function complete.cases() will give you a vector that is TRUE if the
# the case is complete and FALSE if there are missing values.

# is.na() returns TRUE if the value is missing, FALSE if the value is observed
# colSums() calculates the sum of values in each column of a data.frame or matrix
# colMeans() calculates the mean of values in each column of a data.frame or matrix
```

```{r mispropr_hint, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#misprop">Hint</button>
<div id = "misprop" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
The function `complete.cases()` will give you a vector that is TRUE if the
the case is complete and FALSE if there are missing values.

`is.na()` returns `TRUE` if the value is missing, `FALSE` if the value is observed

`colSums()` calculates the sum of values in each column of a data.frame or matrix

`colMeans()` calculates the mean of values in each column of a data.frame or matrix
</div>')
```


```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 3\\n")
```

```{r misprop-hint-2, solution = TRUE}
# number and proportion of complete cases
Ncc <- cbind(
  "#" = table(complete.cases(NHANES)),
  "%" = round(100 * table(complete.cases(NHANES))/nrow(NHANES), 2)
)
rownames(Ncc) <- c("incompl.", "complete")
Ncc

# number and proportion of missing values per variable
cbind("# NA" = sort(colSums(is.na(NHANES))),
      "% NA" = round(sort(colMeans(is.na(NHANES))) * 100, 2))

```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 4\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```


Our data contains `height`, `weight` and `BMI`. 
Check the missing data pattern specifically for those three variables.

```{r heightweight, exercise = TRUE}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 4\\n")
```

```{r heightweight-solution, solution = TRUE}
# Three solutions to choose from:
md.pattern(NHANES[, c("height", "weight", "BMI")])

with(NHANES, table(is.na(height), is.na(weight), is.na(BMI)))

library(plyr)
ddply(NHANES, c(height = "ifelse(is.na(height), 'missing', 'observed')",
                weight = "ifelse(is.na(weight), 'missing', 'observed')",
                BMI = "ifelse(is.na(BMI), 'missing', 'observed')"),
      summarize,
      N = length(height)
)
```

As we have already seen in the lecture, there are quite a number of cases where
only either `height` or `weight` is missing. `BMI` is only observed when both
components are observed. To use all available information, we want to 
impute `height` and `weight` separately and calculate `BMI` from the imputed values.


```{r, eval = static, echo = FALSE}
asis_output("#### Task 5\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Because we might expect that hypertensive medication is only prescribed
for patients with hypertension, we will also look into the variables `HyperMed` 
and `hypten`. Make a table of the two variables to confirm our expectation.
Make sure that missing values are also displayed in that table!
```{r hyptentab, exercise = TRUE}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 5\\n")
```

```{r hyptentab-solution, solution = TRUE}
with(NHANES, table(HyperMed, hypten, exclude = NULL))
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 6\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Furthermore, we can expect a systematic relationship between `hypchol` and
`chol`. Find out how these two variables are related.

```{r hypchol, exercise = TRUE}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 6\\n")
```


```{r hypchol-solution, solution = TRUE}
with(NHANES, plot(chol ~ hypchol))

with(NHANES, summary(chol[hypchol == "no"]))
with(NHANES, summary(chol[hypchol == "yes"]))
```

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

It seems that `hypchol` is defined as having `chol > 6.2`, which makes `hypchol`
dependent on `chol`. 


### Distribution of the data {.tabset .tabset-fade .tabset-pills}
Before imputing the missing data it is important to take a look at how the 
incomplete variables are distributed so that we can choose appropriate
imputation models.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Visualize the distributions of the incomplete continuous and categorical 
variables.
Pay attention to

* whether continuous distributions deviate considerably from the normal distribution,
* if variables have values close to the limits of the range they are defined in,
* whether categorical variables are very unbalanced (i.e., some category very small).


```{r distr, exercise = TRUE, fig.width = 9, fig.height = 8, exercise.setup = "educrecode"}

```

```{r, echo = F, results = 'asis', eval = static}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#distrhint">Hint</button>
<div id = "distrhint" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
**Hint:** You may want to use the functions `hist()`, `table()` and `barplot()`.
  
Of course, you could also use the **ggplot2** package.
</div>
')
```


```{r distr-hint-1, include = !static}
# You may want to use the functions hist(), table() and barplot().
# Of course, you could also use the ggplot2 package.

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r distr-solution, solution = TRUE, fig.width = 9, fig.height = 9}
# One option that allows to quickly get an overview of all variables,
# categorical and continuous

nc <- max(5, ceiling(sqrt(ncol(NHANES))))
nr <- ceiling(ncol(NHANES) / nc)
par(mfrow = c(nr, nc), mgp = c(2, 0.6, 0), mar = c(2, 3, 3, 0.5))
for (i in 1:ncol(NHANES)) {
  if (is.numeric(NHANES[, i])) {
    hist(NHANES[, i], nclass = 50, xlab = "",
         main = paste0(names(NHANES[i]), " (",
                       round(mean(is.na(NHANES[, i])) * 100, 2), "% NA)")
    )
  } else {
    barplot(table(NHANES[, i]), ylab = "Frequency",
            main = paste0(names(NHANES[i]), " (",
                          round(mean(is.na(NHANES[, i])) * 100, 2), "% NA)"))
  }
}
```




## Imputation
Now that we know how our data and the missing values are distributed, we are 
ready to impute!

### Set-up run {.tabset .tabset-fade .tabset-pills}

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

First, do a set-up run of `mice()`, without any iterations (`maxit = 0`).
This is to get all the objects that we may need to adjust in order to customize
the imputation to our data.

If you need help to figure out what you need to specify take a look at the
help page [`?mice`](https://www.rdocumentation.org/packages/mice/versions/2.46.0/topics/mice).

```{r eval = !static, echo = FALSE}
asis_output("Note: This command will not produce any output.")
```

```{r imp0, exercise = TRUE, exercise.setup = "educrecode"}
imp0 <- 
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r imp0-solution, solution = TRUE}
imp0 <- mice(NHANES, maxit = 0)
```

```{r, eval = static, echo = FALSE}
asis_output("Note: This command will not produce any output.")
```



### Imputation method {.tabset .tabset-fade .tabset-pills}
There are many imputation methods available in **mice**. You can find the list in
the help page of the `mice()` function. We will focus here on the following
ones:

```{r, echo = F}
knitr::kable(micemeths[micemeths$type == "basic", -4], row.names = F)
```

The default imputation methods that `mice()` selects can be specified in the
argument `defaultMethod`. 

If unspecified, `mice` will use 

* `pmm` for numerical columns,
* `logreg` for factor columns with two categories, 
* `polyreg` for columns with unordered and 
* `polr` for columns with ordered factors with more than two categories.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

When a normal imputation model seems to be appropriate for most of the 
continuous covariates, you may want to specify `norm` as
the default method in the setup run. Let's do that:

```{r imp0v2, exercise = TRUE, exercise.setup = "educrecode"}
imp0 <- ...(..., defaultMethod = ...)
```

```{r imp0v2-hint-1, eval = !static, echo = FALSE}
# The order for the types of variables is:
# continuous, binary, factor, ordered factor
```

```{r imp0v2_hint, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#imp0v2">Hint</button>
<div id = "imp0v2" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
The order of the types of variable is: continuous, binary, factor, ordered factor.
</div>')
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```


```{r imp0v2-hint-2, solution = TRUE}
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Looking at the histograms we made for the continuous variables, we can see
that the variable `creat` has a skewed distribution, so using a normal imputation
model may not work well. 

Let's change the imputation method for `creat` so that it is imputed with predictive mean matching:

```{r changeimpmod-setup, exercise.setup = "educrecode", eval = !static, echo = FALSE}
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
```

```{r changeimpmod, exercise = TRUE}
meth <- ...

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r changeimpmod-solution, solution = TRUE}
meth <- imp0$meth
meth["creat"] <- "pmm"
```


### Predictor matrix {.tabset .tabset-fade .tabset-pills}
```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```


We can now check out if we need to make any changes to the `predictorMatrix` 
argument. 
```{r predmat-setup, eval = !static, echo = FALSE}
imp0 <- mice(NHANES, maxit = 0,
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
meth <- imp0$meth
meth["creat"] <- "pmm"
```

```{r predmat, exercise = TRUE}
pred <-
pred
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

```{r predmat-solution, solution = TRUE}
pred <- imp0$predictorMatrix
pred
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Remember that we wanted to impute `height` and `weight` separately? But let's
use `BMI` to impute the other variables. 
And since `HyperMed` does not give us a lot more information than `hypten`, but
has a lot more missing values, we do not want to use it as a predictor variable.

Go ahead and apply the necessary changes to  `pred` and `meth`:
```{r changepred-setup, include = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
meth <- imp0$meth
meth["creat"] <- "pmm"

pred <- imp0$pred
```

```{r changepred, exercise = TRUE}

```

```{r changepred-hint-1, eval = !static, echo = FALSE}
# For passive imputation, you need to specify the formula used to calculate
# BMI in meth using "~I(...)".
```

```{r changepred_hint1, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#changepred">Hint</button>
<div id = "changepred" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
For passive imputation, you need to specify the formula used to calculate BMI in meth using `"~I(...)"`.
</div>')
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r changepred-solution, solution = TRUE}
pred[c("height", "weight"), "BMI"] <- 0
pred[, c("height", "weight")] <- 0
pred["height", "weight"] <- 1
pred["weight", "height"] <- 1

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0


meth["BMI"] <- "~I(weight/height^2)"
meth["HyperMed"] <- ""
```

### Visit sequence {.tabset .tabset-fade .tabset-pills}
```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```


To make sure that the imputed values of `BMI` match the imputed values of
`height` and `weight`,`BMI` needs to be imputed after `height` and `weight`.
Get the `visitSequence` from `imp0` (using `imp0$visitSequence`) and change it
if necessary.

```{r changevisseq-setup, include = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
meth <- imp0$meth
meth["creat"] <- "pmm"

pred <- imp0$pred
pred[c("height", "weight"), "BMI"] <- 0
pred[, c("height", "weight")] <- 0
pred["height", "weight"] <- 1
pred["weight", "height"] <- 1

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0


meth["BMI"] <- "~I(weight/height^2)"
meth["HyperMed"] <- ""
```

```{r changevisseq, exercise = TRUE}
visSeq <- ...
...
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r changevisseq-solution, solution = TRUE}
visSeq <- imp0$visitSequence

# the lazy version:
visSeq <- c(visSeq[-2], visSeq[2])

# the save version:
# To make sure you still do the correct thing if the order of the columns in 
# NHANES would change
which_BMI <- match("BMI", visSeq)
visSeq <- c(visSeq[-which_BMI], visSeq[which_BMI])
```



### Run the imputation  {.tabset .tabset-fade .tabset-pills}
```{r allprep, include = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
meth <- imp0$meth
meth["creat"] <- "pmm"
meth["HyperMed"] <- ""

pred <- imp0$pred

pred[c("height", "weight"), "BMI"] <- 0
pred[, c("height", "weight")] <- 0
pred["height", "weight"] <- 1
pred["weight", "height"] <- 1

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0

meth["BMI"] <- "~I(weight/height^2)"
meth["HyperMed"] <- ""

visSeq <- imp0$visitSequence
which_BMI <- match("BMI", visSeq)
visSeq <- c(visSeq[-which_BMI], visSeq[which_BMI])
```

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```



With the changes that we have made to the `predictorMatrix` and `method`, we
can now perform the imputation. Use `m = 5` and `maxit = 10`.

```{r runimp, exercise = TRUE, exercise.timelimit = 100, exercise.setup = "allprep"}
imp <- 
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r runimp-solution, solution = TRUE, cache = TRUE}
imp <- mice(NHANES, method = meth, predictorMatrix = pred, visitSequence = visSeq,
            maxit = 10, m = 5,
            seed = 2018)
```

```{r saveimp, include = FALSE, eval = static, cache = TRUE}
savedimps_imp <- mice(NHANES, method = meth, predictorMatrix = pred,
                      visitSequence = visSeq,
                      maxit = 10, m = 5,
                      seed = 2018)
savedimps_impnaive <- mice(NHANES, maxit = 10, m = 5, seed = 2018)

save(savedimps_imp,
     savedimps_impnaive, file = "www/imps.RData")
```

`mice()` prints the name of the variable being imputed for each
iteration and imputation. If you run `mice()` on your own computer the output
will show up continuously. There, you may notice that imputation is slowest for 
categorical variables, especially when they have many categories.

You can hide the lengthy output by specifying
`printFlag = FALSE`.



## Investigate the imputation
### Type of class {.tabset .tabset-fade .tabset-pills}

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

`mice()` does not return a `data.frame`. 
Find out the class of the object returned by `mice()` function using the 
function `class()`, and take a look at the [help file](https://www.rdocumentation.org/packages/mice/versions/2.46.0/topics/mids-class) for this class:

```{r allimp, echo = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
meth <- imp0$meth
meth["creat"] <- "pmm"
meth["HyperMed"] <- ""

pred <- imp0$pred

pred[c("height", "weight"), "BMI"] <- 0
pred[, c("height", "weight")] <- 0
pred["height", "weight"] <- 1
pred["weight", "height"] <- 1

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0

meth["BMI"] <- "~I(weight/height^2)"
meth["HyperMed"] <- ""

visSeq <- imp0$visitSequence
which_BMI <- match("BMI", names(visSeq))
visSeq <- c(visSeq[-which_BMI], visSeq[which_BMI])

impnaive <- savedimps_impnaive
imp <- savedimps_imp
```


```{r findclass, exercise = TRUE, exercise.setup = "allimp"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r findclass-solution, solution = TRUE}
class(imp)
```



### Elements of the `mids` object {.tabset .tabset-fade .tabset-pills}
We see that `imp` is an object of class `mids`.

The [help file](https://www.rdocumentation.org/packages/mice/versions/2.46.0/topics/mids-class) tells us that a `mids` object is a list with several elements:

```{r, echo = FALSE}
midsdf <- rbind(
  c("`call`:", "The call that created the `mids` object."),
  c("`data`:", "A copy of the incomplete data set."),
  c("`where`:", "The missingness indicator matrix."),
  c("`m`:",
    "The number of imputations."),
  c("`nmis`:",
    "The number of missing observations per variable."),
  c("`imp`:",
    paste0("The imputed values: A list of `ncol(data)` components,",
           "each list component is a matrix with `nmis[j]` rows and `m` columns.")),
  c("`method`:",
    "The vector imputation methods."),
  c("`predictorMatrix`:",
    "The predictor matrix."),
  c("`visitSequence`:", 
    "The sequence in which columns are visited during imputation."),
  c("`post`:",
    "A vector of strings of length `ncol(data)` with commands for post-processing."),
  c("`seed`:",
    "The seed value of the solution."),
  c("`iteration`:", 
    "The number of iterations."),
  c("`lastSeedValue`:",
    "The most recent seed value."),
  c("`chainMean:`", 
    paste0("The mean of imputed values per variable and iteration: ",
           "a list of `m` components. Each component is a matrix with `maxit`",
           "columns and `length(visitSequence)` rows.")),
  c("`chainVar`:",
    paste0("The variances of imputed values per variable and iteration" ,
           "(same structure as `chainMean`).")),
  c("`loggedEvents`:",
    paste0("A matrix with the record of automatic removal actions (details below); ",
           "(`NULL` if no action was made).")),
  c("`pad`:",
    paste0("A list containing the internally used version of the `data`,",
           "`method`, `predictorMatrix`, `visitSequence`, `post` and dummy coding.")
  )
) %>% as.data.frame

names(midsdf) <- c(" ", " ")

midsdf %>% kable(format = 'html') %>%
  kable_styling()
  # row_spec(c(4:10, 12:16), background = "#f2f2f2")
```


**Details of the `loggedEvents`:**

`mice()` does some pre-processing of the data:

  * variables containing missing values, that are not imputed but used as
    predictor are removed
  * constant variables are removed
  * collinear variables are removed
  
  
Furthermore, during each iteration

  * variables that are linearly dependent are removed
  * `polr` imputation that does not converge is replaced by `polyreg`. 
  
The matrix in `loggedEvents` has the following columns:
```{r, echo = FALSE}
rbind(
  c("`it`", "iteration number"), 
  c("`im`", "imputation number"),
  c("`co`", "column number in the data"),
  c("`dep`", "name of the name of the variable being imputed"),
  c("`meth`", "imputation method used"),
  c("`out`", "character vector with names of altered/removed predictors")
) %>%
  kable(format = "html") %>%
  kable_styling()

```


```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

It is good practice to make sure that `mice()` has not done 
any processing of the data that was not planned or that you are not aware of.
This means checking the `loggedEvents`, but also ensuring that the correct
`method`, `predictorMatrix` and `visitSequence` were used.

Do these checks for `imp`.

```{r checkmids, exercise = TRUE, exercise.setup = "allimp"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r checkmids-solution, solution = TRUE}
imp$method
imp$predictorMatrix
imp$visitSequence
imp$loggedEvents
```

### Logged events {.tabset .tabset-fade .tabset-pills}
Checking the `loggedEvents` we see that for `alc`, `educ` and `smoke` the method
`multinom` was used. That is a bit confusing: we specified `polr` in our
imputation method and `imp$method` is indeed `polr` for the three ordinal variables.

The `mice` help page told us that in case `polr` does not converge `polyreg` will
be used. 

```{r, eval = static, echo = FALSE}
asis_output("#### Task 1\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Find out if there is more information in the
[help](https://www.rdocumentation.org/packages/mice/versions/2.46.0/topics/mice.impute.polr)
[pages](https://www.rdocumentation.org/packages/mice/versions/2.46.0/topics/mice.impute.polyreg)
for those two functions.

```{r checkpolr, exercise = TRUE, exercise.setup = "allimp"}

```

```{r, echo = F, results = 'asis'}
if (static) {
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#checkpolr">Hint</button>
<div id = "checkpolr" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">')
} else {
  cat('<div id = "checkpolr-hint">')
}
```

Using `polr` and `polyreg` when specifying the `method` argument in `mice`
actually calls the functions `mice.impute.polr` and  `mice.impute.polyreg`
when running the imputation.

</div>

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 1\\n")
```

The help for `mice.impute.polr()` tells us:

> The call to `polr` might fail, usually because the data are very sparse. 
> In that case, `multinom` is tried as a fallback, and a record is written to 
> the `loggedEvents` component of the `mids` object.

and the help for `mice.impute.polyreg()` says:

> The algorithm of `mice.impute.polyreg` uses the function `multinom()`  from 
> the **nnet** package.

So that explains it, everything seems to be in order, but unfortunately the
ordinal models for `alc`, `educ` and `smoke` did not converge and multinomial models
had to be used instead.

```{r, eval = static, echo = FALSE}
asis_output("#### Task 2\\n")
```

Let's see what else would have come up if we had not prepared the
`predictorMatrix`, `method` and `visitSequence` before imputation.
The object `impnaive` contains the result of 
```{r, eval = FALSE, echo = TRUE, include = TRUE}
impnaive <- mice(NHANES, m = 5, maxit = 10)
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Take a look at the `loggedEvents` of `impnaive`. 

```{r impnaiveloggedEvents, exercise = TRUE, exercise.setup = "allimp"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 2\\n")
```

```{r impnaiveloggedEvents-solution, solution = TRUE}
impnaive$loggedEvents
```


```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```


The `loggedEvents` of the "naive" imputation show that the constant variable
`cohort` was excluded before the imputation (as it should be).

Furthermore, in the imputation model for `HyperMed`, the variable `hypten.1`
was excluded. `hypten.1` is the first dummy variable belonging to `hypten`.
We can check this by looking at `impnaive$pad$categories`:

```{r, eval = FALSE}
impnaive$pad$categories
```

```{r, echo = FALSE}
impnaive <- savedimps_impnaive
impnaive$pad$categories
```

Here, we see in row `r match("hypten", rownames(impnaive$pad$categories))`
that `hypten` has 1 dummy variable and that `hypten.1` 
(row `r match("hypten.1", rownames(impnaive$pad$categories))`) is a dummy variable, belonging to column
`r impnaive$pad$categories$father[match("hypten.1", rownames(impnaive$pad$categories))]`
in the dataset.
Hence, `hypten` was not used in the imputation of `HyperMed`.

<br>

```{r, eval = static, echo = FALSE}
asis_output("#### Task 3\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

We also did not change the `visitSequence` in `impnaive`. Find out what
the effects of that are.

```{r impnaiveVisSeq, exercise = TRUE, exercise.setup = "allimp"}

```

```{r impnaiveVisSeq-hint-1, include = !static, echo = FALSE}
# You can get an imputed datasets from a mids object using the function complete().
# Use ?complete for more information.
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution 3\\n")
```

```{r, impnaiveVisSeq-solution, solution = TRUE}
naiveDF1 <- complete(impnaive, 1)
naivecalcBMI <- with(naiveDF1, weight/height^2)

impDF1 <- complete(imp, 1)
impcalcBMI <- with(impDF1, weight/height^2)

cbind(naiveBMI = naiveDF1$BMI, naivecalcBMI,
      impBMI = impDF1$BMI, impcalcBMI)[which(is.na(NHANES$BMI)), ]

```

When we compare the imputed and calculated values of `BMI` from `impnaive` we
can see that the imputed `height` and `weight` give a different `BMI` than is
imputed. This is because `BMI` is imputed before `weight`, which means that the
most recent imputed value of `weight` is from the previous iteration.

Changing the `visitSequence` in `imp` prevented this inconsistency.


### Convergence {.tabset .tabset-fade .tabset-pills}
The mean and variance of the imputed values per iteration and variable is
stored in the elements `chainMean` and `chainVar` of the `mids` object.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Let's plot them to see if our imputation `imp` has converged:

```{r convergence, exercise = TRUE, exercise.setup = "allimp", fig.width = 9, fig.height = 7}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r convergence-solution, solution = TRUE, fig.width = 9, fig.height = 7}
# implemented plotting function (use layout to change the number of rows and columns)
plot(imp, layout = c(6, 6))

# plot for a single variable
matplot(imp$chainMean["weight", , ], type = "l", ylab = "imputed value",
        xlab = "iteration", main = "weight")

# or the ggplot version
library(ggplot2)
library(reshape2)
ggplot(melt(imp$chainMean), aes(x = Var2, y = value, color = Var3)) +
  geom_line(na.rm = TRUE) +
  facet_wrap("Var1", scales = 'free') +
  theme(legend.position = 'none') +
  xlab("iteration") +
  ylab("imputed value")

```

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

The chains in `imp` seem to have converged, but in practice, more iterations 
should be done to confirm this.

```{r, eval = static, echo = FALSE}
asis_output("#### Continue\\n")
```

In comparison, `impnaive` had some convergence problems:
```{r, fig.width = 9, fig.height = 7}
plot(impnaive, layout = c(6, 6))
```

`height`, and `BMI` show a clear trend and the chains do not mix well, i.e., there
is more variation between the chains than within each chain (the same is the 
case for `weight`). Moreover, `hyperchol` shows some undesired behaviour, where
four chains move upwards and the 5th chain separates from them after half of the
iterations. These are clear signs that there is correlation or identification
problems between these variables and some other variables (which is why we made
adjustments to the `predictorMatrix` for `imp`).

### Imputed values {.tabset .tabset-fade .tabset-pills}
Now that we know that `imp` has converged, we can compare the distribution of
the imputed values against the distribution of the observed values.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Plot the distributions of the imputed variables (continuous and categorical),
and make sure the imputed values are realistic (e.g., no height of 2.50m or weight of 10kg for adults).
If there are differences in the distributions of observed and imputed values see if
those differences can be explained by other variables.

```{r distrplot, exercise = TRUE, exercise.setup = "allimp", fig.width = 9, fig.height = 7}

```

```{r impdistrhint, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#impdistrhint">Hint</button>
<div id = "impdistrhint" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
You can use `densityplot()` and `probplot()` to get plots for all continuous and
categorical variables.

You can obtain `probplot()` from [https://gist.github.com/NErler/0d00375da460dd33839b98faeee2fdab](https://gist.github.com/NErler/0d00375da460dd33839b98faeee2fdab).
 
To check all imputed values you can either get a summary of the `imp` element
of the `mids` object or create a complete dataset containing all imputations
using the function `complete()` and get the summary of that.
</div>')
```

```{r distrplot-hint-1, include = !static, echo = FALSE}
# You can use "densityplot()" and "probplot()" to get plots for all continuous and
# categorical variables.
# 
# To check all imputed values you can either get a summary of the "imp" element
# of the mids object or create a complete dataset containing all imputations
# using the function "complete()" and get the summary of that.
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r distrplot-solution, solution = TRUE, fig.width = 9, fig.height = 7, cache = TRUE}
densityplot(imp)

# create a long dataset with all imputed data sets stacked onto each other
longDF <- complete(imp, "long")
summary(longDF)

# get the summary of the "raw" imputed values
lapply(imp$imp, function(x) 
  summary(unlist(x))
)

# look into the distribution of SBP and height
densityplot(imp, ~SBP|hypten)
densityplot(imp, ~height|gender)

# plot for all categorical variables
probplot(imp)

# look into the categorical variables where proportions of imputed and observed differ
probplot(imp, smoke ~ alc)
probplot(imp, alc ~ gender)
```

```{r, eval = !static, echo = FALSE}
asis_output("###\\n")
```

Unfortunately, we have some negative imputed values for `bili`. Often, this
would not result in bias in the analysis, but may be difficult to explain
when providing a summary of the imputed data in a publication.
In the present example we can see that the observed values have a slightly
right-skewed distribution, compared to the imputed values. Re-doing the
imputation with `pmm` instead of `norm` for `bili` should fix this.
(However, since the imputations seem fine overall, and there is little knowledge
gain in re-doing the previous steps, we will skip this repetition 
in this practical.)

The distributions of the imputed values for `height` and `SBP` differ a bit
from the distributions of the observed data, but these differences can be explained
by adjusting for `gender` and `hypten`.

We also imputed a larger proportion than might have been expected in the 
highest category of `alc`, and the distribution of values for `educ` and `smoke`
looks a bit weird.

The difference in distribution of `alc` could be explained by `gender`.
`smoke` and `educ` each have only one missing value, which makes it difficult
to judge the distribution of imputed values. Adjusting the distributions
of observed `smoke` for `alc` shows that the subject with missing
smoking status was a drinker, and drinkers were more often in the `current`
group of smoking.



## Analysis
### Fitting models on `mids` objects {.tabset .tabset-fade .tabset-pills}
When we are confident that the imputation was successfull, the imputed data can
be analysed with any complete data method. 

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Choose any analysis model of interest and fit it on the imputed data. 
The model could for instance be a linear regression model (using `lm`) or a 
generalized linear regression model, e.g., logistic regression
(using `glm()`).
Find out the `class` and structure of the resulting object.

```{r analysisstep_hint, eval = static, results = 'asis', echo = FALSE}
cat('<button type="button" class="btn btn-info btn-sm" data-toggle="collapse" data-target="#analysisstep">Hint</button>
<div id = "analysisstep" class="collapse" style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
`imp` is not a dataframe but an object of class `mids`, so we cannot use the
normal specification of a model in which we specify the argument `data`
to be a `data.frame`. Instead, use `with(imp, <model function without data>)`.
</div>')
```

```{r analysisstep, exercise = TRUE, exercise.setup = "allimp"}

```

```{r analysisstep-hint-1, include = !static}
# "imp" is not a dataframe but an object of class "mids", so we cannot use the
# normal specification of a model in which we specify the argument "data"
# to be a "data.frame". Instead, use "with(imp, <model function without data>)".

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r analysisstep-hint-2}
# for example:
models1 <- with(imp, lm(SBP ~ age + gender + bili + chol + BMI))
models2 <- with(imp, glm(hypchol ~ age + gender + bili + race + BMI,
                       family = "binomial"))
models3 <- with(imp, glm(creat ~ age + gender + uricacid + WC + BMI,
                       family = Gamma(link = 'log')))
```

```{r analysisstep-hint-3}
# to determine the class
class(models1)

# to determine the structure
names(models1)
lapply(models1, class)

# explore further
models1$analyses
summary(models1$analyses[[1]])
```



### Structure of `mira` objects {.tabset .tabset-fade .tabset-pills}
Analyses performed on `mids` objects will result in a `mira` object
(multiply imputed repeated analyses).


A `mira` object is a list with the following elements:
```{r, echo = FALSE}
miradf <- rbind(
  c("`call`:", "The call that created the `mira` object."),
  c("`call1`:", "The call that created the `mids` object."),
  c("`nmis`:", "The number of missing observations per column."),
  c("`analyses`:",
    paste0("The models fitted on each of the imputed datasets: ",
           "A list with `imp$m` components, where each component contains
           a fitted model object."))
) %>% as.data.frame

names(miradf) <- c(" ", " ")

miradf %>% kable(format = 'html') %>%
  kable_styling()
```

The class of each of the components of `imp$analyses` will depend on the
type of model that was fitted.

## Pooling 
```{r, eval = static, echo = FALSE}
asis_output('### Combining results {.tabset .tabset-fade .tabset-pills}')
```

To pool the results from the repeated analyses contained in a `mira` object,
the function `pool()` can be used.

```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

Pool one of the provided `mira` objects (`models1`, `models2` or `models3`)
and investigate its structure.

```{r impmods, echo = FALSE}
NHANES$educ <- as.ordered(NHANES$educ)
imp0 <- mice(NHANES, maxit = 0, 
             defaultMethod = c("norm", 'logreg', 'polyreg', 'polr'))
meth <- imp0$meth
meth["creat"] <- "pmm"
meth["HyperMed"] <- ""

pred <- imp0$pred

pred[c("height", "weight"), "BMI"] <- 0
pred[, c("height", "weight")] <- 0
pred["height", "weight"] <- 1
pred["weight", "height"] <- 1

pred[, "HyperMed"] <- 0

pred["chol", "hypchol"] <- 0

meth["BMI"] <- "~I(weight/height^2)"
meth["HyperMed"] <- ""

visSeq <- imp0$visitSequence
which_BMI <- match("BMI", names(visSeq))
visSeq <- c(visSeq[-which_BMI], visSeq[which_BMI])

impnaive <- savedimps_impnaive
imp <- savedimps_imp

models1 <- with(imp, lm(SBP ~ age + gender + bili + chol + BMI))
models2 <- with(imp, glm(hypchol ~ age + gender + bili + race + BMI, 
                       family = "binomial"))
models3 <- with(imp, glm(creat ~ age + gender + uricacid + WC + BMI,
                       family = Gamma(link = 'log')))
```

```{r pooling, exercise = TRUE, exercise.setup = "impmods"}

```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```


```{r pooling-solution, solution = TRUE}
# pool the model
pooled1 <- pool(models1)

# investigate the structure
class(pooled1)
names(pooled1)
str(pooled1)
```


### Structure of `mipo` objects {.tabset .tabset-fade .tabset-pills}
Pooling of a `mira` object results in a `mipo` object (multiply imputed pooled analysis).

The `mipo` object is a list that has the following elements:
```{r, echo = FALSE}
pooldf <- rbind(
  c("`call`:", "The call that created the `mipo` object."),
  c("`call1`:", "The call that created the `mids` object."),
  c("`call2`:", "The call that created the `mira` object."),
  c("`data`", "The original, incomplete data."),
  c("`nmis`:", "The number of missing values per variable."),
  c("`m`:", "The number of imputations."),
  c("`qhat`:", "The coefficients from all analyses: a matrix with `m` rows and `npar`columns."),
  c("`u`:", paste0("The variance-covariance matrix of the coefficients from each analysis: ",
                   "an array of dimension `c(m, npar, npar)`.")),
  c("`qbar`:", "The pooled parameter estimates: a vector of length `npar`."),
  c("`ubar`:", paste0("The average within imputation variance: ",
                      "a matrix with `npar` rows and `npar` columns containing ",
                      "the averaged variance-covariance matrices.")),
  c("`b`:", "The between imputation variance-covariance matrix ($u + b + b/m$)."),
  c("`t`:", "The total variance-covariance matrix."),
  c("`r`:", "The relative increase in variance due to the missing values."),
  c("`dfcom`:", "Degrees of freedom in the hypothetically complete data (`N - # free parameters`)."),
  c("`df`:", "Degrees of freedom associated with the $t$-statistics."),
  c("`fmi`:", "Fraction of missing information."),
  c("`lambda`:", "Proportion of the variation due to the missing values: $(b+b/m)/t$.")
) %>% as.data.frame

names(pooldf) <- c(" ", " ")

pooldf %>% kable(format = 'html') %>%
  kable_styling()
```

From the elements contained in the `mipo` object, we could obtain the pooled
coefficients (`qbar`) and variances (`t`),
and calculate the pooled confidence intervals and p-values by hand, using the
function provided in the course notes.

However, the function `summary()` applied to the `mipo` object will do this for us.

<div style="border:1px; border-style:solid; padding: 1em; border-color:#D11450">
**Note:**<br>
`pool()` extracts the model coefficients and variance-covariance matrices using
the functions `coef()` and `vcov()`. Hence, pooling using the `pool()` 
function from **mice** only works for those types of models for which these functions
will return the regression coefficients and corresponding variance-covariance matrix.

Moreover, `pool()` only works for objects of class `mira`. When data has been
imputed in a different package/software, or analyses have not been performed
in the way described above, a list of fitted models can be converted to a `mira`
object using `as.mira()`.
</div>


```{r, eval = static, echo = FALSE}
asis_output("#### Task\\n")
```

```{r, eval = static, echo = FALSE}
asis_output('<div style="border:2px; border-style:solid; padding: 1em; border-color:#446E9B">')
```

```{r, eval = static, echo = FALSE}
asis_output("Get the summary of the pooled results.")
```

```{r summarypooled, exercise = TRUE, exercise.setup = "impmods"}
pooled1 <- pool(models1)
...
```

```{r, eval = static, echo = FALSE}
asis_output("</div>")

asis_output("#### Solution\\n")
```

```{r, summarypooled-solution, solution = TRUE}
pooled1 <- pool(models1)
summary(pooled1)
```


<div style="border:1px; border-style:solid; padding: 1em; border-color:#1F78B4">
<center>
**You have reached the end of this practical. Well done!**
</center>
</div>
